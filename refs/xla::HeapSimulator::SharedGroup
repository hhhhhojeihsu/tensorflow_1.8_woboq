<def f='tensorflow/tensorflow/compiler/xla/service/heap_simulator.h' l='162' ll='165'/>
<size>16</size>
<doc f='tensorflow/tensorflow/compiler/xla/service/heap_simulator.h' l='148'>// In addition to Alloc and Free, the heap simulator exposes a concept of
  // buffer sharing.  When ShareBuffer is called, instead of allocating new
  // space for the buffer, it associates the buffer with a previously allocated
  // (or shared) buffer.  Each group of mutually-shared buffers points to a
  // single SharedGroup instance, which is a shared control block.
  //
  // This forced buffer sharing is hidden from the underlying heap algorithm,
  // which only sees a regular Alloc call on the canonical buffer.  The
  // corresponding Free call is delayed until the liveness of all shared buffers
  // in the group has expired, which is tracked via the refcount.  The results
  // are post-processed in Finish to add chunks for shared buffers.
  //
  // The shared_buffers_ map associates each shared buffer (including the
  // canonical) to its SharedGroup control block.</doc>
<mbr r='xla::HeapSimulator::SharedGroup::canonical' o='0' t='const xla::LogicalBuffer *'/>
<mbr r='xla::HeapSimulator::SharedGroup::refcount' o='64' t='int64'/>
