<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>heap_simulator.h source code [tensorflow/tensorflow/compiler/xla/service/heap_simulator.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="xla::DecreasingSizeRunsHeap,xla::HeapAlgorithm,xla::HeapSimulator,xla::LazyBestFitHeap,xla::NoFragmentationStatsHeap "/>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'tensorflow/tensorflow/compiler/xla/service/heap_simulator.h'; var root_path = '../../../../..'; var data_path = 'https://code.woboq.org/data';</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../..'>tensorflow</a>/<a href='../../..'>tensorflow</a>/<a href='../..'>compiler</a>/<a href='..'>xla</a>/<a href='./'>service</a>/<a href='heap_simulator.h.html'>heap_simulator.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.</i></td></tr>
<tr><th id="2">2</th><td><i></i></td></tr>
<tr><th id="3">3</th><td><i>Licensed under the Apache License, Version 2.0 (the "License");</i></td></tr>
<tr><th id="4">4</th><td><i>you may not use this file except in compliance with the License.</i></td></tr>
<tr><th id="5">5</th><td><i>You may obtain a copy of the License at</i></td></tr>
<tr><th id="6">6</th><td><i></i></td></tr>
<tr><th id="7">7</th><td><i>    <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></i></td></tr>
<tr><th id="8">8</th><td><i></i></td></tr>
<tr><th id="9">9</th><td><i>Unless required by applicable law or agreed to in writing, software</i></td></tr>
<tr><th id="10">10</th><td><i>distributed under the License is distributed on an "AS IS" BASIS,</i></td></tr>
<tr><th id="11">11</th><td><i>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i></td></tr>
<tr><th id="12">12</th><td><i>See the License for the specific language governing permissions and</i></td></tr>
<tr><th id="13">13</th><td><i>limitations under the License.</i></td></tr>
<tr><th id="14">14</th><td><i>==============================================================================*/</i></td></tr>
<tr><th id="15">15</th><td></td></tr>
<tr><th id="16">16</th><td><u>#<span data-ppcond="16">ifndef</span> <span class="macro" data-ref="_M/TENSORFLOW_COMPILER_XLA_SERVICE_HEAP_SIMULATOR_H_">TENSORFLOW_COMPILER_XLA_SERVICE_HEAP_SIMULATOR_H_</span></u></td></tr>
<tr><th id="17">17</th><td><u>#define <dfn class="macro" id="_M/TENSORFLOW_COMPILER_XLA_SERVICE_HEAP_SIMULATOR_H_" data-ref="_M/TENSORFLOW_COMPILER_XLA_SERVICE_HEAP_SIMULATOR_H_">TENSORFLOW_COMPILER_XLA_SERVICE_HEAP_SIMULATOR_H_</dfn></u></td></tr>
<tr><th id="18">18</th><td></td></tr>
<tr><th id="19">19</th><td><u>#include <a href="../../../../../include/c++/5/memory.html">&lt;memory&gt;</a></u></td></tr>
<tr><th id="20">20</th><td><u>#include <a href="../../../../../include/c++/5/set.html">&lt;set&gt;</a></u></td></tr>
<tr><th id="21">21</th><td><u>#include <a href="../../../../../include/c++/5/utility.html">&lt;utility&gt;</a></u></td></tr>
<tr><th id="22">22</th><td><u>#include <a href="../../../../../include/c++/5/vector.html">&lt;vector&gt;</a></u></td></tr>
<tr><th id="23">23</th><td></td></tr>
<tr><th id="24">24</th><td><u>#include "tensorflow/compiler/xla/service/hlo.pb.h"</u></td></tr>
<tr><th id="25">25</th><td><u>#include <a href="hlo_computation.h.html">"tensorflow/compiler/xla/service/hlo_computation.h"</a></u></td></tr>
<tr><th id="26">26</th><td><u>#include <a href="hlo_instruction.h.html">"tensorflow/compiler/xla/service/hlo_instruction.h"</a></u></td></tr>
<tr><th id="27">27</th><td><u>#include <a href="hlo_ordering.h.html">"tensorflow/compiler/xla/service/hlo_ordering.h"</a></u></td></tr>
<tr><th id="28">28</th><td><u>#include <a href="logical_buffer.h.html">"tensorflow/compiler/xla/service/logical_buffer.h"</a></u></td></tr>
<tr><th id="29">29</th><td><u>#include <a href="tuple_points_to_analysis.h.html">"tensorflow/compiler/xla/service/tuple_points_to_analysis.h"</a></u></td></tr>
<tr><th id="30">30</th><td><u>#include <a href="../statusor.h.html">"tensorflow/compiler/xla/statusor.h"</a></u></td></tr>
<tr><th id="31">31</th><td><u>#include <a href="../../../core/lib/gtl/flatmap.h.html">"tensorflow/core/lib/gtl/flatmap.h"</a></u></td></tr>
<tr><th id="32">32</th><td><u>#include <a href="../../../core/lib/gtl/flatset.h.html">"tensorflow/core/lib/gtl/flatset.h"</a></u></td></tr>
<tr><th id="33">33</th><td></td></tr>
<tr><th id="34">34</th><td><b>namespace</b> <span class="namespace">xla</span> {</td></tr>
<tr><th id="35">35</th><td></td></tr>
<tr><th id="36">36</th><td><i>// Forward declare classes defined below.</i></td></tr>
<tr><th id="37">37</th><td><b>class</b> <a class="type" href="#xla::HeapAlgorithm" title='xla::HeapAlgorithm' data-ref="xla::HeapAlgorithm">HeapAlgorithm</a>;</td></tr>
<tr><th id="38">38</th><td></td></tr>
<tr><th id="39">39</th><td><i>// HeapSimulator assigns buffer offsets by running a simulation of a regular</i></td></tr>
<tr><th id="40">40</th><td><i>// memory heap with Alloc and Free calls.  It only works for completely</i></td></tr>
<tr><th id="41">41</th><td><i>// sequential instruction sequences.  Unlike regular heaps, we have the</i></td></tr>
<tr><th id="42">42</th><td><i>// advantage that the sequence of Alloc and Free calls is known up-front; we</i></td></tr>
<tr><th id="43">43</th><td><i>// don't need to return the assignment of buffer offsets until the very end.</i></td></tr>
<tr><th id="44">44</th><td><b>class</b> <dfn class="type def" id="xla::HeapSimulator" title='xla::HeapSimulator' data-ref="xla::HeapSimulator">HeapSimulator</dfn> {</td></tr>
<tr><th id="45">45</th><td> <b>public</b>:</td></tr>
<tr><th id="46">46</th><td>  <i>// Chunk represents a contiguous piece of memory.  Each LogicalBuffer will be</i></td></tr>
<tr><th id="47">47</th><td><i>  // associated with a chunk in the assignment result.</i></td></tr>
<tr><th id="48">48</th><td>  <b>struct</b> <dfn class="type def" id="xla::HeapSimulator::Chunk" title='xla::HeapSimulator::Chunk' data-ref="xla::HeapSimulator::Chunk">Chunk</dfn> {</td></tr>
<tr><th id="49">49</th><td>    <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="decl" id="xla::HeapSimulator::Chunk::offset" title='xla::HeapSimulator::Chunk::offset' data-ref="xla::HeapSimulator::Chunk::offset">offset</dfn>;</td></tr>
<tr><th id="50">50</th><td>    <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="decl" id="xla::HeapSimulator::Chunk::size" title='xla::HeapSimulator::Chunk::size' data-ref="xla::HeapSimulator::Chunk::size">size</dfn>;</td></tr>
<tr><th id="51">51</th><td></td></tr>
<tr><th id="52">52</th><td>    <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="decl def" id="_ZNK3xla13HeapSimulator5Chunk9chunk_endEv" title='xla::HeapSimulator::Chunk::chunk_end' data-ref="_ZNK3xla13HeapSimulator5Chunk9chunk_endEv">chunk_end</dfn>() <em>const</em> { <b>return</b> <a class="member" href="#xla::HeapSimulator::Chunk::offset" title='xla::HeapSimulator::Chunk::offset' data-ref="xla::HeapSimulator::Chunk::offset">offset</a> + <a class="member" href="#xla::HeapSimulator::Chunk::size" title='xla::HeapSimulator::Chunk::size' data-ref="xla::HeapSimulator::Chunk::size">size</a>; }</td></tr>
<tr><th id="53">53</th><td>  };</td></tr>
<tr><th id="54">54</th><td></td></tr>
<tr><th id="55">55</th><td>  <i>// Result represents the result of the heap simulation.</i></td></tr>
<tr><th id="56">56</th><td>  <b>struct</b> <dfn class="type def" id="xla::HeapSimulator::Result" title='xla::HeapSimulator::Result' data-ref="xla::HeapSimulator::Result">Result</dfn> {</td></tr>
<tr><th id="57">57</th><td>    <i>// The assignment of buffers to chunks.</i></td></tr>
<tr><th id="58">58</th><td>    <span class="namespace">tensorflow::gtl::</span><a class="type" href="../../../core/lib/gtl/flatmap.h.html#tensorflow::gtl::FlatMap" title='tensorflow::gtl::FlatMap' data-ref="tensorflow::gtl::FlatMap">FlatMap</a>&lt;<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>*, <a class="type" href="#xla::HeapSimulator::Chunk" title='xla::HeapSimulator::Chunk' data-ref="xla::HeapSimulator::Chunk">Chunk</a>&gt; <dfn class="decl" id="xla::HeapSimulator::Result::chunk_map" title='xla::HeapSimulator::Result::chunk_map' data-ref="xla::HeapSimulator::Result::chunk_map">chunk_map</dfn>;</td></tr>
<tr><th id="59">59</th><td></td></tr>
<tr><th id="60">60</th><td>    <i>// The total size in bytes of the heap, containing all assigned chunks.</i></td></tr>
<tr><th id="61">61</th><td>    <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="decl" id="xla::HeapSimulator::Result::heap_size" title='xla::HeapSimulator::Result::heap_size' data-ref="xla::HeapSimulator::Result::heap_size">heap_size</dfn> = <var>0</var>;</td></tr>
<tr><th id="62">62</th><td></td></tr>
<tr><th id="63">63</th><td>    <i>// The total size in bytes of heap fragmentation.</i></td></tr>
<tr><th id="64">64</th><td>    <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="decl" id="xla::HeapSimulator::Result::fragmentation_size" title='xla::HeapSimulator::Result::fragmentation_size' data-ref="xla::HeapSimulator::Result::fragmentation_size">fragmentation_size</dfn> = <var>0</var>;</td></tr>
<tr><th id="65">65</th><td></td></tr>
<tr><th id="66">66</th><td>    <i>// A trace of heap simulation events.</i></td></tr>
<tr><th id="67">67</th><td>    <span class='type' title='xla::HeapSimulatorTrace' data-ref="xla::HeapSimulatorTrace">HeapSimulatorTrace</span> <dfn class="decl" id="xla::HeapSimulator::Result::debug_trace" title='xla::HeapSimulator::Result::debug_trace' data-ref="xla::HeapSimulator::Result::debug_trace">debug_trace</dfn>;</td></tr>
<tr><th id="68">68</th><td>  };</td></tr>
<tr><th id="69">69</th><td></td></tr>
<tr><th id="70">70</th><td>  <i>// The different options to be passed to the Run() APIs.</i></td></tr>
<tr><th id="71">71</th><td>  <b>struct</b> <dfn class="type def" id="xla::HeapSimulator::Options" title='xla::HeapSimulator::Options' data-ref="xla::HeapSimulator::Options">Options</dfn> {</td></tr>
<tr><th id="72">72</th><td>    <dfn class="decl def" id="_ZN3xla13HeapSimulator7OptionsC1Ev" title='xla::HeapSimulator::Options::Options' data-ref="_ZN3xla13HeapSimulator7OptionsC1Ev">Options</dfn>()</td></tr>
<tr><th id="73">73</th><td>        : <a class="member" href="#xla::HeapSimulator::Options::may_reuse_operand_buffers" title='xla::HeapSimulator::Options::may_reuse_operand_buffers' data-ref="xla::HeapSimulator::Options::may_reuse_operand_buffers">may_reuse_operand_buffers</a>(<b>true</b>),</td></tr>
<tr><th id="74">74</th><td>          <a class="member" href="#xla::HeapSimulator::Options::alloc_constants" title='xla::HeapSimulator::Options::alloc_constants' data-ref="xla::HeapSimulator::Options::alloc_constants">alloc_constants</a>(<b>false</b>),</td></tr>
<tr><th id="75">75</th><td>          <a class="member" href="#xla::HeapSimulator::Options::buffers_to_assign" title='xla::HeapSimulator::Options::buffers_to_assign' data-ref="xla::HeapSimulator::Options::buffers_to_assign">buffers_to_assign</a>(<b>nullptr</b>) {}</td></tr>
<tr><th id="76">76</th><td></td></tr>
<tr><th id="77">77</th><td>    <i>// Whether a buffer about to be Free()-ed, can be recycled for a new born</i></td></tr>
<tr><th id="78">78</th><td><i>    // one, hence collapsing Free()+Alloc() calls (default true).</i></td></tr>
<tr><th id="79">79</th><td>    <em>bool</em> <dfn class="decl" id="xla::HeapSimulator::Options::may_reuse_operand_buffers" title='xla::HeapSimulator::Options::may_reuse_operand_buffers' data-ref="xla::HeapSimulator::Options::may_reuse_operand_buffers">may_reuse_operand_buffers</dfn>;</td></tr>
<tr><th id="80">80</th><td>    <i>// Whether to issue Alloc() and Free() calls for constants (default false).</i></td></tr>
<tr><th id="81">81</th><td>    <em>bool</em> <dfn class="decl" id="xla::HeapSimulator::Options::alloc_constants" title='xla::HeapSimulator::Options::alloc_constants' data-ref="xla::HeapSimulator::Options::alloc_constants">alloc_constants</dfn>;</td></tr>
<tr><th id="82">82</th><td>    <i>// If 'buffers_to_assign' is provided, only those buffers are assigned</i></td></tr>
<tr><th id="83">83</th><td><i>    // offsets, otherwise all buffers defined by the instructions are assigned.</i></td></tr>
<tr><th id="84">84</th><td>    <em>const</em> <span class="namespace">tensorflow::gtl::</span><a class="type" href="../../../core/lib/gtl/flatset.h.html#tensorflow::gtl::FlatSet" title='tensorflow::gtl::FlatSet' data-ref="tensorflow::gtl::FlatSet">FlatSet</a>&lt;<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>*&gt;* <dfn class="decl" id="xla::HeapSimulator::Options::buffers_to_assign" title='xla::HeapSimulator::Options::buffers_to_assign' data-ref="xla::HeapSimulator::Options::buffers_to_assign">buffers_to_assign</dfn>;</td></tr>
<tr><th id="85">85</th><td>  };</td></tr>
<tr><th id="86">86</th><td></td></tr>
<tr><th id="87">87</th><td>  <i>// Run the heap simulation with the given algorithm, assuming the given</i></td></tr>
<tr><th id="88">88</th><td><i>  // module_sequence, which must contain a topologically-consistent total</i></td></tr>
<tr><th id="89">89</th><td><i>  // ordering of all instructions within each computation. The result is invalid</i></td></tr>
<tr><th id="90">90</th><td><i>  // if instructions are not run in exactly this sequence.</i></td></tr>
<tr><th id="91">91</th><td><i>  //</i></td></tr>
<tr><th id="92">92</th><td><i>  // Running heap simulation on the whole module tends to save memory, compared</i></td></tr>
<tr><th id="93">93</th><td><i>  // to running on a per-computation basis, since we can re-use buffer space for</i></td></tr>
<tr><th id="94">94</th><td><i>  // called sub-computations.</i></td></tr>
<tr><th id="95">95</th><td><i>  //</i></td></tr>
<tr><th id="96">96</th><td>  <em>static</em> <a class="type" href="../statusor.h.html#xla::StatusOr" title='xla::StatusOr' data-ref="xla::StatusOr">StatusOr</a>&lt;<a class="type" href="#xla::HeapSimulator::Result" title='xla::HeapSimulator::Result' data-ref="xla::HeapSimulator::Result">Result</a>&gt; <dfn class="decl" id="_ZN3xla13HeapSimulator3RunESt10unique_ptrINS_13HeapAlgorithmESt14default_deleteIS2_EERKNS_9HloModuleERKN10tensorflow3gtl7FlatMapIPKNS_14HloComputation11042075" title='xla::HeapSimulator::Run' data-ref="_ZN3xla13HeapSimulator3RunESt10unique_ptrINS_13HeapAlgorithmESt14default_deleteIS2_EERKNS_9HloModuleERKN10tensorflow3gtl7FlatMapIPKNS_14HloComputation11042075">Run</dfn>(</td></tr>
<tr><th id="97">97</th><td>      <span class="namespace">std::</span><a class="type" href="../../../../../include/c++/5/bits/unique_ptr.h.html#std::unique_ptr" title='std::unique_ptr' data-ref="std::unique_ptr">unique_ptr</a>&lt;<a class="type" href="#xla::HeapAlgorithm" title='xla::HeapAlgorithm' data-ref="xla::HeapAlgorithm">HeapAlgorithm</a>&gt; <dfn class="local col2 decl" id="252algorithm" title='algorithm' data-type='std::unique_ptr&lt;HeapAlgorithm&gt;' data-ref="252algorithm">algorithm</dfn>, <em>const</em> <a class="type" href="hlo_module.h.html#xla::HloModule" title='xla::HloModule' data-ref="xla::HloModule">HloModule</a>&amp; <dfn class="local col3 decl" id="253module" title='module' data-type='const xla::HloModule &amp;' data-ref="253module">module</dfn>,</td></tr>
<tr><th id="98">98</th><td>      <em>const</em> <a class="type" href="hlo_ordering.h.html#xla::SequentialHloOrdering" title='xla::SequentialHloOrdering' data-ref="xla::SequentialHloOrdering">SequentialHloOrdering</a>::<a class="typedef" href="hlo_ordering.h.html#xla::SequentialHloOrdering::HloModuleSequence" title='xla::SequentialHloOrdering::HloModuleSequence' data-type='tensorflow::gtl::FlatMap&lt;const HloComputation *, std::vector&lt;const HloInstruction *&gt; &gt;' data-ref="xla::SequentialHloOrdering::HloModuleSequence">HloModuleSequence</a>&amp; <dfn class="local col4 decl" id="254module_sequence" title='module_sequence' data-type='const SequentialHloOrdering::HloModuleSequence &amp;' data-ref="254module_sequence">module_sequence</dfn>,</td></tr>
<tr><th id="99">99</th><td>      <em>const</em> <a class="type" href="tuple_points_to_analysis.h.html#xla::TuplePointsToAnalysis" title='xla::TuplePointsToAnalysis' data-ref="xla::TuplePointsToAnalysis">TuplePointsToAnalysis</a>&amp; <dfn class="local col5 decl" id="255points_to_analysis" title='points_to_analysis' data-type='const xla::TuplePointsToAnalysis &amp;' data-ref="255points_to_analysis">points_to_analysis</dfn>,</td></tr>
<tr><th id="100">100</th><td>      <em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>::<a class="typedef" href="logical_buffer.h.html#xla::LogicalBuffer::SizeFunction" title='xla::LogicalBuffer::SizeFunction' data-type='std::function&lt;int64 (const LogicalBuffer &amp;)&gt;' data-ref="xla::LogicalBuffer::SizeFunction">SizeFunction</a>&amp; <dfn class="local col6 decl" id="256size_fn" title='size_fn' data-type='const LogicalBuffer::SizeFunction &amp;' data-ref="256size_fn">size_fn</dfn>,</td></tr>
<tr><th id="101">101</th><td>      <em>const</em> <a class="type" href="#xla::HeapSimulator::Options" title='xla::HeapSimulator::Options' data-ref="xla::HeapSimulator::Options">Options</a>&amp; <dfn class="local col7 decl" id="257options" title='options' data-type='const xla::HeapSimulator::Options &amp;' data-ref="257options">options</dfn> = <a class="type" href="#xla::HeapSimulator::Options" title='xla::HeapSimulator::Options' data-ref="xla::HeapSimulator::Options">Options</a><a class="ref" href="#_ZN3xla13HeapSimulator7OptionsC1Ev" title='xla::HeapSimulator::Options::Options' data-ref="_ZN3xla13HeapSimulator7OptionsC1Ev">(</a>));</td></tr>
<tr><th id="102">102</th><td></td></tr>
<tr><th id="103">103</th><td>  <i>// Same as above, but runs on a single computation. The 'instruction_sequence'</i></td></tr>
<tr><th id="104">104</th><td><i>  // must contain a topologically-consistent total ordering of all instructions</i></td></tr>
<tr><th id="105">105</th><td><i>  // in the computation. The result is invalid if instructions are not run in</i></td></tr>
<tr><th id="106">106</th><td><i>  // exactly this sequence.</i></td></tr>
<tr><th id="107">107</th><td>  <em>static</em> <a class="type" href="../statusor.h.html#xla::StatusOr" title='xla::StatusOr' data-ref="xla::StatusOr">StatusOr</a>&lt;<a class="type" href="#xla::HeapSimulator::Result" title='xla::HeapSimulator::Result' data-ref="xla::HeapSimulator::Result">Result</a>&gt; <dfn class="decl" id="_ZN3xla13HeapSimulator3RunESt10unique_ptrINS_13HeapAlgorithmESt14default_deleteIS2_EERKNS_14HloComputationERKSt6vectorIPKNS_14HloInstructionESaISC_EER10335569" title='xla::HeapSimulator::Run' data-ref="_ZN3xla13HeapSimulator3RunESt10unique_ptrINS_13HeapAlgorithmESt14default_deleteIS2_EERKNS_14HloComputationERKSt6vectorIPKNS_14HloInstructionESaISC_EER10335569">Run</dfn>(</td></tr>
<tr><th id="108">108</th><td>      <span class="namespace">std::</span><a class="type" href="../../../../../include/c++/5/bits/unique_ptr.h.html#std::unique_ptr" title='std::unique_ptr' data-ref="std::unique_ptr">unique_ptr</a>&lt;<a class="type" href="#xla::HeapAlgorithm" title='xla::HeapAlgorithm' data-ref="xla::HeapAlgorithm">HeapAlgorithm</a>&gt; <dfn class="local col8 decl" id="258algorithm" title='algorithm' data-type='std::unique_ptr&lt;HeapAlgorithm&gt;' data-ref="258algorithm">algorithm</dfn>,</td></tr>
<tr><th id="109">109</th><td>      <em>const</em> <a class="type" href="hlo_computation.h.html#xla::HloComputation" title='xla::HloComputation' data-ref="xla::HloComputation">HloComputation</a>&amp; <dfn class="local col9 decl" id="259computation" title='computation' data-type='const xla::HloComputation &amp;' data-ref="259computation">computation</dfn>,</td></tr>
<tr><th id="110">110</th><td>      <em>const</em> <span class="namespace">std::</span><a class="type" href="../../../../../include/c++/5/bits/stl_vector.h.html#std::vector" title='std::vector' data-ref="std::vector">vector</a>&lt;<em>const</em> <a class="type" href="hlo_instruction.h.html#xla::HloInstruction" title='xla::HloInstruction' data-ref="xla::HloInstruction">HloInstruction</a>*&gt;&amp; <dfn class="local col0 decl" id="260instruction_sequence" title='instruction_sequence' data-type='const std::vector&lt;const HloInstruction *&gt; &amp;' data-ref="260instruction_sequence">instruction_sequence</dfn>,</td></tr>
<tr><th id="111">111</th><td>      <em>const</em> <a class="type" href="tuple_points_to_analysis.h.html#xla::TuplePointsToAnalysis" title='xla::TuplePointsToAnalysis' data-ref="xla::TuplePointsToAnalysis">TuplePointsToAnalysis</a>&amp; <dfn class="local col1 decl" id="261points_to_analysis" title='points_to_analysis' data-type='const xla::TuplePointsToAnalysis &amp;' data-ref="261points_to_analysis">points_to_analysis</dfn>,</td></tr>
<tr><th id="112">112</th><td>      <em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>::<a class="typedef" href="logical_buffer.h.html#xla::LogicalBuffer::SizeFunction" title='xla::LogicalBuffer::SizeFunction' data-type='std::function&lt;int64 (const LogicalBuffer &amp;)&gt;' data-ref="xla::LogicalBuffer::SizeFunction">SizeFunction</a>&amp; <dfn class="local col2 decl" id="262size_fn" title='size_fn' data-type='const LogicalBuffer::SizeFunction &amp;' data-ref="262size_fn">size_fn</dfn>,</td></tr>
<tr><th id="113">113</th><td>      <em>const</em> <a class="type" href="#xla::HeapSimulator::Options" title='xla::HeapSimulator::Options' data-ref="xla::HeapSimulator::Options">Options</a>&amp; <dfn class="local col3 decl" id="263options" title='options' data-type='const xla::HeapSimulator::Options &amp;' data-ref="263options">options</dfn> = <a class="type" href="#xla::HeapSimulator::Options" title='xla::HeapSimulator::Options' data-ref="xla::HeapSimulator::Options">Options</a><a class="ref" href="#_ZN3xla13HeapSimulator7OptionsC1Ev" title='xla::HeapSimulator::Options::Options' data-ref="_ZN3xla13HeapSimulator7OptionsC1Ev">(</a>));</td></tr>
<tr><th id="114">114</th><td></td></tr>
<tr><th id="115">115</th><td> <b>private</b>:</td></tr>
<tr><th id="116">116</th><td>  <i>// If 'module_sequence' is non-null, it is used to find kCall and kWhile</i></td></tr>
<tr><th id="117">117</th><td><i>  // sub-computations, and the heap simulation for those sub-computations will</i></td></tr>
<tr><th id="118">118</th><td><i>  // be run recursively. I.e. the simulation is run over the whole module.</i></td></tr>
<tr><th id="119">119</th><td>  <dfn class="decl" id="_ZN3xla13HeapSimulatorC1ESt10unique_ptrINS_13HeapAlgorithmESt14default_deleteIS2_EERKSt8functionIFxRKNS_13LogicalBufferEEERKNS0_7OptionsEPKN10tensorfl5678477" title='xla::HeapSimulator::HeapSimulator' data-ref="_ZN3xla13HeapSimulatorC1ESt10unique_ptrINS_13HeapAlgorithmESt14default_deleteIS2_EERKSt8functionIFxRKNS_13LogicalBufferEEERKNS0_7OptionsEPKN10tensorfl5678477">HeapSimulator</dfn>(</td></tr>
<tr><th id="120">120</th><td>      <span class="namespace">std::</span><a class="type" href="../../../../../include/c++/5/bits/unique_ptr.h.html#std::unique_ptr" title='std::unique_ptr' data-ref="std::unique_ptr">unique_ptr</a>&lt;<a class="type" href="#xla::HeapAlgorithm" title='xla::HeapAlgorithm' data-ref="xla::HeapAlgorithm">HeapAlgorithm</a>&gt; <dfn class="local col4 decl" id="264algorithm" title='algorithm' data-type='std::unique_ptr&lt;HeapAlgorithm&gt;' data-ref="264algorithm">algorithm</dfn>,</td></tr>
<tr><th id="121">121</th><td>      <em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>::<a class="typedef" href="logical_buffer.h.html#xla::LogicalBuffer::SizeFunction" title='xla::LogicalBuffer::SizeFunction' data-type='std::function&lt;int64 (const LogicalBuffer &amp;)&gt;' data-ref="xla::LogicalBuffer::SizeFunction">SizeFunction</a>&amp; <dfn class="local col5 decl" id="265size_fn" title='size_fn' data-type='const LogicalBuffer::SizeFunction &amp;' data-ref="265size_fn">size_fn</dfn>, <em>const</em> <a class="type" href="#xla::HeapSimulator::Options" title='xla::HeapSimulator::Options' data-ref="xla::HeapSimulator::Options">Options</a>&amp; <dfn class="local col6 decl" id="266options" title='options' data-type='const xla::HeapSimulator::Options &amp;' data-ref="266options">options</dfn>,</td></tr>
<tr><th id="122">122</th><td>      <em>const</em> <a class="type" href="hlo_ordering.h.html#xla::SequentialHloOrdering" title='xla::SequentialHloOrdering' data-ref="xla::SequentialHloOrdering">SequentialHloOrdering</a>::<a class="typedef" href="hlo_ordering.h.html#xla::SequentialHloOrdering::HloModuleSequence" title='xla::SequentialHloOrdering::HloModuleSequence' data-type='tensorflow::gtl::FlatMap&lt;const HloComputation *, std::vector&lt;const HloInstruction *&gt; &gt;' data-ref="xla::SequentialHloOrdering::HloModuleSequence">HloModuleSequence</a>* <dfn class="local col7 decl" id="267module_sequence" title='module_sequence' data-type='const SequentialHloOrdering::HloModuleSequence *' data-ref="267module_sequence">module_sequence</dfn>);</td></tr>
<tr><th id="123">123</th><td>  <dfn class="decl" id="_ZN3xla13HeapSimulatorD1Ev" title='xla::HeapSimulator::~HeapSimulator' data-ref="_ZN3xla13HeapSimulatorD1Ev">~HeapSimulator</dfn>();</td></tr>
<tr><th id="124">124</th><td></td></tr>
<tr><th id="125">125</th><td>  <a class="type" href="../../../core/lib/core/status.h.html#tensorflow::Status" title='tensorflow::Status' data-ref="tensorflow::Status">Status</a> <dfn class="decl" id="_ZN3xla13HeapSimulator14RunComputationERKNS_14HloComputationERKSt6vectorIPKNS_14HloInstructionESaIS7_EERKNS_21TuplePointsToAnalysisE" title='xla::HeapSimulator::RunComputation' data-ref="_ZN3xla13HeapSimulator14RunComputationERKNS_14HloComputationERKSt6vectorIPKNS_14HloInstructionESaIS7_EERKNS_21TuplePointsToAnalysisE">RunComputation</dfn>(</td></tr>
<tr><th id="126">126</th><td>      <em>const</em> <a class="type" href="hlo_computation.h.html#xla::HloComputation" title='xla::HloComputation' data-ref="xla::HloComputation">HloComputation</a>&amp; <dfn class="local col8 decl" id="268computation" title='computation' data-type='const xla::HloComputation &amp;' data-ref="268computation">computation</dfn>,</td></tr>
<tr><th id="127">127</th><td>      <em>const</em> <span class="namespace">std::</span><a class="type" href="../../../../../include/c++/5/bits/stl_vector.h.html#std::vector" title='std::vector' data-ref="std::vector">vector</a>&lt;<em>const</em> <a class="type" href="hlo_instruction.h.html#xla::HloInstruction" title='xla::HloInstruction' data-ref="xla::HloInstruction">HloInstruction</a>*&gt;&amp; <dfn class="local col9 decl" id="269instruction_sequence" title='instruction_sequence' data-type='const std::vector&lt;const HloInstruction *&gt; &amp;' data-ref="269instruction_sequence">instruction_sequence</dfn>,</td></tr>
<tr><th id="128">128</th><td>      <em>const</em> <a class="type" href="tuple_points_to_analysis.h.html#xla::TuplePointsToAnalysis" title='xla::TuplePointsToAnalysis' data-ref="xla::TuplePointsToAnalysis">TuplePointsToAnalysis</a>&amp; <dfn class="local col0 decl" id="270points_to_analysis" title='points_to_analysis' data-type='const xla::TuplePointsToAnalysis &amp;' data-ref="270points_to_analysis">points_to_analysis</dfn>);</td></tr>
<tr><th id="129">129</th><td></td></tr>
<tr><th id="130">130</th><td>  <em>bool</em> <dfn class="decl" id="_ZNK3xla13HeapSimulator12IgnoreBufferEPKNS_13LogicalBufferE" title='xla::HeapSimulator::IgnoreBuffer' data-ref="_ZNK3xla13HeapSimulator12IgnoreBufferEPKNS_13LogicalBufferE">IgnoreBuffer</dfn>(<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col1 decl" id="271buffer" title='buffer' data-type='const xla::LogicalBuffer *' data-ref="271buffer">buffer</dfn>) <em>const</em>;</td></tr>
<tr><th id="131">131</th><td>  <em>void</em> <dfn class="decl" id="_ZN3xla13HeapSimulator5AllocEPKNS_13LogicalBufferEPKNS_14HloInstructionE" title='xla::HeapSimulator::Alloc' data-ref="_ZN3xla13HeapSimulator5AllocEPKNS_13LogicalBufferEPKNS_14HloInstructionE">Alloc</dfn>(<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col2 decl" id="272buffer" title='buffer' data-type='const xla::LogicalBuffer *' data-ref="272buffer">buffer</dfn>, <em>const</em> <a class="type" href="hlo_instruction.h.html#xla::HloInstruction" title='xla::HloInstruction' data-ref="xla::HloInstruction">HloInstruction</a>* <dfn class="local col3 decl" id="273instruction" title='instruction' data-type='const xla::HloInstruction *' data-ref="273instruction">instruction</dfn>);</td></tr>
<tr><th id="132">132</th><td>  <em>void</em> <dfn class="decl" id="_ZN3xla13HeapSimulator4FreeEPKNS_13LogicalBufferEPKNS_14HloInstructionE" title='xla::HeapSimulator::Free' data-ref="_ZN3xla13HeapSimulator4FreeEPKNS_13LogicalBufferEPKNS_14HloInstructionE">Free</dfn>(<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col4 decl" id="274buffer" title='buffer' data-type='const xla::LogicalBuffer *' data-ref="274buffer">buffer</dfn>, <em>const</em> <a class="type" href="hlo_instruction.h.html#xla::HloInstruction" title='xla::HloInstruction' data-ref="xla::HloInstruction">HloInstruction</a>* <dfn class="local col5 decl" id="275instruction" title='instruction' data-type='const xla::HloInstruction *' data-ref="275instruction">instruction</dfn>);</td></tr>
<tr><th id="133">133</th><td>  <em>void</em> <dfn class="decl" id="_ZN3xla13HeapSimulator11ShareBufferEPKNS_13LogicalBufferES3_PKNS_14HloInstructionE" title='xla::HeapSimulator::ShareBuffer' data-ref="_ZN3xla13HeapSimulator11ShareBufferEPKNS_13LogicalBufferES3_PKNS_14HloInstructionE">ShareBuffer</dfn>(<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col6 decl" id="276buffer" title='buffer' data-type='const xla::LogicalBuffer *' data-ref="276buffer">buffer</dfn>, <em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col7 decl" id="277shared" title='shared' data-type='const xla::LogicalBuffer *' data-ref="277shared">shared</dfn>,</td></tr>
<tr><th id="134">134</th><td>                   <em>const</em> <a class="type" href="hlo_instruction.h.html#xla::HloInstruction" title='xla::HloInstruction' data-ref="xla::HloInstruction">HloInstruction</a>* <dfn class="local col8 decl" id="278instruction" title='instruction' data-type='const xla::HloInstruction *' data-ref="278instruction">instruction</dfn>);</td></tr>
<tr><th id="135">135</th><td>  <a class="type" href="#xla::HeapSimulator::Result" title='xla::HeapSimulator::Result' data-ref="xla::HeapSimulator::Result">Result</a> <dfn class="decl" id="_ZN3xla13HeapSimulator6FinishEv" title='xla::HeapSimulator::Finish' data-ref="_ZN3xla13HeapSimulator6FinishEv">Finish</dfn>();</td></tr>
<tr><th id="136">136</th><td></td></tr>
<tr><th id="137">137</th><td>  <em>void</em> <dfn class="decl" id="_ZN3xla13HeapSimulator14FillDebugTraceENS_29HeapSimulatorTrace_Event_KindEPKNS_13LogicalBufferEPKNS_14HloInstructionES4_" title='xla::HeapSimulator::FillDebugTrace' data-ref="_ZN3xla13HeapSimulator14FillDebugTraceENS_29HeapSimulatorTrace_Event_KindEPKNS_13LogicalBufferEPKNS_14HloInstructionES4_">FillDebugTrace</dfn>(<span class='type' title='xla::HeapSimulatorTrace' data-ref="xla::HeapSimulatorTrace">HeapSimulatorTrace</span>::<span class='typedef' title='xla::HeapSimulatorTrace::Event' data-type='xla::HeapSimulatorTrace_Event' data-ref="xla::HeapSimulatorTrace::Event">Event</span>::<span class='typedef' title='xla::HeapSimulatorTrace_Event::Kind' data-type='xla::HeapSimulatorTrace_Event_Kind' data-ref="xla::HeapSimulatorTrace_Event::Kind">Kind</span> <dfn class="local col9 decl" id="279kind" title='kind' data-type='HeapSimulatorTrace::Event::Kind' data-ref="279kind">kind</dfn>,</td></tr>
<tr><th id="138">138</th><td>                      <em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col0 decl" id="280buffer" title='buffer' data-type='const xla::LogicalBuffer *' data-ref="280buffer">buffer</dfn>,</td></tr>
<tr><th id="139">139</th><td>                      <em>const</em> <a class="type" href="hlo_instruction.h.html#xla::HloInstruction" title='xla::HloInstruction' data-ref="xla::HloInstruction">HloInstruction</a>* <dfn class="local col1 decl" id="281instruction" title='instruction' data-type='const xla::HloInstruction *' data-ref="281instruction">instruction</dfn>,</td></tr>
<tr><th id="140">140</th><td>                      <em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col2 decl" id="282shared_with_canonical" title='shared_with_canonical' data-type='const xla::LogicalBuffer *' data-ref="282shared_with_canonical">shared_with_canonical</dfn>);</td></tr>
<tr><th id="141">141</th><td></td></tr>
<tr><th id="142">142</th><td>  <em>const</em> <span class="namespace">std::</span><a class="type" href="../../../../../include/c++/5/bits/unique_ptr.h.html#std::unique_ptr" title='std::unique_ptr' data-ref="std::unique_ptr">unique_ptr</a>&lt;<a class="type" href="#xla::HeapAlgorithm" title='xla::HeapAlgorithm' data-ref="xla::HeapAlgorithm">HeapAlgorithm</a>&gt; <dfn class="decl" id="xla::HeapSimulator::no_fragmentation_stats_" title='xla::HeapSimulator::no_fragmentation_stats_' data-ref="xla::HeapSimulator::no_fragmentation_stats_">no_fragmentation_stats_</dfn>;</td></tr>
<tr><th id="143">143</th><td>  <em>const</em> <span class="namespace">std::</span><a class="type" href="../../../../../include/c++/5/bits/unique_ptr.h.html#std::unique_ptr" title='std::unique_ptr' data-ref="std::unique_ptr">unique_ptr</a>&lt;<a class="type" href="#xla::HeapAlgorithm" title='xla::HeapAlgorithm' data-ref="xla::HeapAlgorithm">HeapAlgorithm</a>&gt; <dfn class="decl" id="xla::HeapSimulator::algorithm_" title='xla::HeapSimulator::algorithm_' data-ref="xla::HeapSimulator::algorithm_">algorithm_</dfn>;</td></tr>
<tr><th id="144">144</th><td>  <em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>::<a class="typedef" href="logical_buffer.h.html#xla::LogicalBuffer::SizeFunction" title='xla::LogicalBuffer::SizeFunction' data-type='std::function&lt;int64 (const LogicalBuffer &amp;)&gt;' data-ref="xla::LogicalBuffer::SizeFunction">SizeFunction</a> <dfn class="decl" id="xla::HeapSimulator::size_fn_" title='xla::HeapSimulator::size_fn_' data-ref="xla::HeapSimulator::size_fn_">size_fn_</dfn>;</td></tr>
<tr><th id="145">145</th><td>  <em>const</em> <a class="type" href="#xla::HeapSimulator::Options" title='xla::HeapSimulator::Options' data-ref="xla::HeapSimulator::Options">Options</a> <dfn class="decl" id="xla::HeapSimulator::options_" title='xla::HeapSimulator::options_' data-ref="xla::HeapSimulator::options_">options_</dfn>;</td></tr>
<tr><th id="146">146</th><td>  <em>const</em> <a class="type" href="hlo_ordering.h.html#xla::SequentialHloOrdering" title='xla::SequentialHloOrdering' data-ref="xla::SequentialHloOrdering">SequentialHloOrdering</a>::<a class="typedef" href="hlo_ordering.h.html#xla::SequentialHloOrdering::HloModuleSequence" title='xla::SequentialHloOrdering::HloModuleSequence' data-type='tensorflow::gtl::FlatMap&lt;const HloComputation *, std::vector&lt;const HloInstruction *&gt; &gt;' data-ref="xla::SequentialHloOrdering::HloModuleSequence">HloModuleSequence</a>* <dfn class="decl" id="xla::HeapSimulator::module_sequence_" title='xla::HeapSimulator::module_sequence_' data-ref="xla::HeapSimulator::module_sequence_">module_sequence_</dfn>;</td></tr>
<tr><th id="147">147</th><td></td></tr>
<tr><th id="148">148</th><td>  <i>// In addition to Alloc and Free, the heap simulator exposes a concept of</i></td></tr>
<tr><th id="149">149</th><td><i>  // buffer sharing.  When ShareBuffer is called, instead of allocating new</i></td></tr>
<tr><th id="150">150</th><td><i>  // space for the buffer, it associates the buffer with a previously allocated</i></td></tr>
<tr><th id="151">151</th><td><i>  // (or shared) buffer.  Each group of mutually-shared buffers points to a</i></td></tr>
<tr><th id="152">152</th><td><i>  // single SharedGroup instance, which is a shared control block.</i></td></tr>
<tr><th id="153">153</th><td><i>  //</i></td></tr>
<tr><th id="154">154</th><td><i>  // This forced buffer sharing is hidden from the underlying heap algorithm,</i></td></tr>
<tr><th id="155">155</th><td><i>  // which only sees a regular Alloc call on the canonical buffer.  The</i></td></tr>
<tr><th id="156">156</th><td><i>  // corresponding Free call is delayed until the liveness of all shared buffers</i></td></tr>
<tr><th id="157">157</th><td><i>  // in the group has expired, which is tracked via the refcount.  The results</i></td></tr>
<tr><th id="158">158</th><td><i>  // are post-processed in Finish to add chunks for shared buffers.</i></td></tr>
<tr><th id="159">159</th><td><i>  //</i></td></tr>
<tr><th id="160">160</th><td><i>  // The shared_buffers_ map associates each shared buffer (including the</i></td></tr>
<tr><th id="161">161</th><td><i>  // canonical) to its SharedGroup control block.</i></td></tr>
<tr><th id="162">162</th><td>  <b>struct</b> <dfn class="type def" id="xla::HeapSimulator::SharedGroup" title='xla::HeapSimulator::SharedGroup' data-ref="xla::HeapSimulator::SharedGroup">SharedGroup</dfn> {</td></tr>
<tr><th id="163">163</th><td>    <em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="decl" id="xla::HeapSimulator::SharedGroup::canonical" title='xla::HeapSimulator::SharedGroup::canonical' data-ref="xla::HeapSimulator::SharedGroup::canonical">canonical</dfn> = <b>nullptr</b>;</td></tr>
<tr><th id="164">164</th><td>    <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="decl" id="xla::HeapSimulator::SharedGroup::refcount" title='xla::HeapSimulator::SharedGroup::refcount' data-ref="xla::HeapSimulator::SharedGroup::refcount">refcount</dfn> = <var>0</var>;</td></tr>
<tr><th id="165">165</th><td>  };</td></tr>
<tr><th id="166">166</th><td>  <span class="namespace">tensorflow::gtl::</span><a class="type" href="../../../core/lib/gtl/flatmap.h.html#tensorflow::gtl::FlatMap" title='tensorflow::gtl::FlatMap' data-ref="tensorflow::gtl::FlatMap">FlatMap</a>&lt;<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>*, <span class="namespace">std::</span><a class="type" href="../../../../../include/c++/5/bits/shared_ptr_base.h.html#std::shared_ptr" title='std::shared_ptr' data-ref="std::shared_ptr">shared_ptr</a>&lt;<a class="type" href="#xla::HeapSimulator::SharedGroup" title='xla::HeapSimulator::SharedGroup' data-ref="xla::HeapSimulator::SharedGroup">SharedGroup</a>&gt;&gt;</td></tr>
<tr><th id="167">167</th><td>      <dfn class="decl" id="xla::HeapSimulator::shared_buffers_" title='xla::HeapSimulator::shared_buffers_' data-ref="xla::HeapSimulator::shared_buffers_">shared_buffers_</dfn>;</td></tr>
<tr><th id="168">168</th><td></td></tr>
<tr><th id="169">169</th><td>  <i>// Hold some sets for error-checking the sequence of Alloc and Free calls.</i></td></tr>
<tr><th id="170">170</th><td>  <span class="namespace">tensorflow::gtl::</span><a class="type" href="../../../core/lib/gtl/flatset.h.html#tensorflow::gtl::FlatSet" title='tensorflow::gtl::FlatSet' data-ref="tensorflow::gtl::FlatSet">FlatSet</a>&lt;<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>*&gt; <dfn class="decl" id="xla::HeapSimulator::allocated_buffers_" title='xla::HeapSimulator::allocated_buffers_' data-ref="xla::HeapSimulator::allocated_buffers_">allocated_buffers_</dfn>;</td></tr>
<tr><th id="171">171</th><td>  <span class="namespace">tensorflow::gtl::</span><a class="type" href="../../../core/lib/gtl/flatset.h.html#tensorflow::gtl::FlatSet" title='tensorflow::gtl::FlatSet' data-ref="tensorflow::gtl::FlatSet">FlatSet</a>&lt;<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>*&gt; <dfn class="decl" id="xla::HeapSimulator::freed_buffers_" title='xla::HeapSimulator::freed_buffers_' data-ref="xla::HeapSimulator::freed_buffers_">freed_buffers_</dfn>;</td></tr>
<tr><th id="172">172</th><td></td></tr>
<tr><th id="173">173</th><td>  <i>// Debugging information filled in while the heap simulator runs.</i></td></tr>
<tr><th id="174">174</th><td>  <span class='type' title='xla::HeapSimulatorTrace' data-ref="xla::HeapSimulatorTrace">HeapSimulatorTrace</span> <dfn class="decl" id="xla::HeapSimulator::debug_trace_" title='xla::HeapSimulator::debug_trace_' data-ref="xla::HeapSimulator::debug_trace_">debug_trace_</dfn>;</td></tr>
<tr><th id="175">175</th><td>};</td></tr>
<tr><th id="176">176</th><td></td></tr>
<tr><th id="177">177</th><td><i>// Abstract base class describing a heap simulation algorithm that assigns</i></td></tr>
<tr><th id="178">178</th><td><i>// offsets to buffers.  A sequence of Alloc / Free calls will be made, with the</i></td></tr>
<tr><th id="179">179</th><td><i>// same semantics as a regular memory heap.  Finish will be called at the end to</i></td></tr>
<tr><th id="180">180</th><td><i>// collect the simulation results.</i></td></tr>
<tr><th id="181">181</th><td><b>class</b> <dfn class="type def" id="xla::HeapAlgorithm" title='xla::HeapAlgorithm' data-ref="xla::HeapAlgorithm">HeapAlgorithm</dfn> {</td></tr>
<tr><th id="182">182</th><td> <b>public</b>:</td></tr>
<tr><th id="183">183</th><td>  <b>using</b> <dfn class="typedef" id="xla::HeapAlgorithm::Chunk" title='xla::HeapAlgorithm::Chunk' data-type='HeapSimulator::Chunk' data-ref="xla::HeapAlgorithm::Chunk">Chunk</dfn> = <a class="type" href="#xla::HeapSimulator" title='xla::HeapSimulator' data-ref="xla::HeapSimulator">HeapSimulator</a>::<a class="type" href="#xla::HeapSimulator::Chunk" title='xla::HeapSimulator::Chunk' data-ref="xla::HeapSimulator::Chunk">Chunk</a>;</td></tr>
<tr><th id="184">184</th><td>  <b>using</b> <dfn class="typedef" id="xla::HeapAlgorithm::Result" title='xla::HeapAlgorithm::Result' data-type='HeapSimulator::Result' data-ref="xla::HeapAlgorithm::Result">Result</dfn> = <a class="type" href="#xla::HeapSimulator" title='xla::HeapSimulator' data-ref="xla::HeapSimulator">HeapSimulator</a>::<a class="type" href="#xla::HeapSimulator::Result" title='xla::HeapSimulator::Result' data-ref="xla::HeapSimulator::Result">Result</a>;</td></tr>
<tr><th id="185">185</th><td></td></tr>
<tr><th id="186">186</th><td>  <b>virtual</b> <dfn class="virtual decl def" id="_ZN3xla13HeapAlgorithmD1Ev" title='xla::HeapAlgorithm::~HeapAlgorithm' data-ref="_ZN3xla13HeapAlgorithmD1Ev">~HeapAlgorithm</dfn>() = <b>default</b>;</td></tr>
<tr><th id="187">187</th><td></td></tr>
<tr><th id="188">188</th><td>  <i>// Alloc allocates a buffer of 'size' bytes.</i></td></tr>
<tr><th id="189">189</th><td>  <b>virtual</b> <em>void</em> <dfn class="virtual decl" id="_ZN3xla13HeapAlgorithm5AllocEPKNS_13LogicalBufferEx" title='xla::HeapAlgorithm::Alloc' data-ref="_ZN3xla13HeapAlgorithm5AllocEPKNS_13LogicalBufferEx">Alloc</dfn>(<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col3 decl" id="283buffer" title='buffer' data-type='const xla::LogicalBuffer *' data-ref="283buffer">buffer</dfn>, <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="local col4 decl" id="284size" title='size' data-type='int64' data-ref="284size">size</dfn>) = <var>0</var>;</td></tr>
<tr><th id="190">190</th><td></td></tr>
<tr><th id="191">191</th><td>  <i>// Free de-allocates a previously allocated buffer.</i></td></tr>
<tr><th id="192">192</th><td>  <b>virtual</b> <em>void</em> <dfn class="virtual decl" id="_ZN3xla13HeapAlgorithm4FreeEPKNS_13LogicalBufferEx" title='xla::HeapAlgorithm::Free' data-ref="_ZN3xla13HeapAlgorithm4FreeEPKNS_13LogicalBufferEx">Free</dfn>(<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col5 decl" id="285buffer" title='buffer' data-type='const xla::LogicalBuffer *' data-ref="285buffer">buffer</dfn>, <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="local col6 decl" id="286size" title='size' data-type='int64' data-ref="286size">size</dfn>) = <var>0</var>;</td></tr>
<tr><th id="193">193</th><td></td></tr>
<tr><th id="194">194</th><td>  <i>// Finish collects the buffer offset assignment results.  Free may only be</i></td></tr>
<tr><th id="195">195</th><td><i>  // called once, after the Alloc and Free calls.</i></td></tr>
<tr><th id="196">196</th><td>  <b>virtual</b> <a class="typedef" href="#xla::HeapAlgorithm::Result" title='xla::HeapAlgorithm::Result' data-type='HeapSimulator::Result' data-ref="xla::HeapAlgorithm::Result">Result</a> <dfn class="virtual decl" id="_ZN3xla13HeapAlgorithm6FinishEv" title='xla::HeapAlgorithm::Finish' data-ref="_ZN3xla13HeapAlgorithm6FinishEv">Finish</dfn>() = <var>0</var>;</td></tr>
<tr><th id="197">197</th><td>};</td></tr>
<tr><th id="198">198</th><td></td></tr>
<tr><th id="199">199</th><td><i>// NoFragmentationStatsHeap computes the heap size assuming no fragmentation;</i></td></tr>
<tr><th id="200">200</th><td><i>// this is the absolute minimum size for a given instruction sequence.  The</i></td></tr>
<tr><th id="201">201</th><td><i>// result.chunk_map returned in Finish is always empty, since we only collect</i></td></tr>
<tr><th id="202">202</th><td><i>// stats, and don't actually compute chunk assignments.</i></td></tr>
<tr><th id="203">203</th><td><b>class</b> <dfn class="type def" id="xla::NoFragmentationStatsHeap" title='xla::NoFragmentationStatsHeap' data-ref="xla::NoFragmentationStatsHeap">NoFragmentationStatsHeap</dfn> : <b>public</b> <a class="type" href="#xla::HeapAlgorithm" title='xla::HeapAlgorithm' data-ref="xla::HeapAlgorithm">HeapAlgorithm</a> {</td></tr>
<tr><th id="204">204</th><td> <b>public</b>:</td></tr>
<tr><th id="205">205</th><td>  <dfn class="decl" id="_ZN3xla24NoFragmentationStatsHeapC1Ev" title='xla::NoFragmentationStatsHeap::NoFragmentationStatsHeap' data-ref="_ZN3xla24NoFragmentationStatsHeapC1Ev">NoFragmentationStatsHeap</dfn>() = <b>default</b>;</td></tr>
<tr><th id="206">206</th><td>  <dfn class="virtual decl" id="_ZN3xla24NoFragmentationStatsHeapD1Ev" title='xla::NoFragmentationStatsHeap::~NoFragmentationStatsHeap' data-ref="_ZN3xla24NoFragmentationStatsHeapD1Ev">~NoFragmentationStatsHeap</dfn>() override = <b>default</b>;</td></tr>
<tr><th id="207">207</th><td></td></tr>
<tr><th id="208">208</th><td>  <em>void</em> <dfn class="virtual decl" id="_ZN3xla24NoFragmentationStatsHeap5AllocEPKNS_13LogicalBufferEx" title='xla::NoFragmentationStatsHeap::Alloc' data-ref="_ZN3xla24NoFragmentationStatsHeap5AllocEPKNS_13LogicalBufferEx">Alloc</dfn>(<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col7 decl" id="287buffer" title='buffer' data-type='const xla::LogicalBuffer *' data-ref="287buffer">buffer</dfn>, <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="local col8 decl" id="288size" title='size' data-type='int64' data-ref="288size">size</dfn>) override;</td></tr>
<tr><th id="209">209</th><td>  <em>void</em> <dfn class="virtual decl" id="_ZN3xla24NoFragmentationStatsHeap4FreeEPKNS_13LogicalBufferEx" title='xla::NoFragmentationStatsHeap::Free' data-ref="_ZN3xla24NoFragmentationStatsHeap4FreeEPKNS_13LogicalBufferEx">Free</dfn>(<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col9 decl" id="289buffer" title='buffer' data-type='const xla::LogicalBuffer *' data-ref="289buffer">buffer</dfn>, <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="local col0 decl" id="290size" title='size' data-type='int64' data-ref="290size">size</dfn>) override;</td></tr>
<tr><th id="210">210</th><td>  <a class="typedef" href="#xla::HeapAlgorithm::Result" title='xla::HeapAlgorithm::Result' data-type='HeapSimulator::Result' data-ref="xla::HeapAlgorithm::Result">Result</a> <dfn class="virtual decl" id="_ZN3xla24NoFragmentationStatsHeap6FinishEv" title='xla::NoFragmentationStatsHeap::Finish' data-ref="_ZN3xla24NoFragmentationStatsHeap6FinishEv">Finish</dfn>() override;</td></tr>
<tr><th id="211">211</th><td></td></tr>
<tr><th id="212">212</th><td> <b>private</b>:</td></tr>
<tr><th id="213">213</th><td>  <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="decl" id="xla::NoFragmentationStatsHeap::current_heap_size_" title='xla::NoFragmentationStatsHeap::current_heap_size_' data-ref="xla::NoFragmentationStatsHeap::current_heap_size_">current_heap_size_</dfn> = <var>0</var>;</td></tr>
<tr><th id="214">214</th><td>  <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="decl" id="xla::NoFragmentationStatsHeap::max_heap_size_" title='xla::NoFragmentationStatsHeap::max_heap_size_' data-ref="xla::NoFragmentationStatsHeap::max_heap_size_">max_heap_size_</dfn> = <var>0</var>;</td></tr>
<tr><th id="215">215</th><td>};</td></tr>
<tr><th id="216">216</th><td></td></tr>
<tr><th id="217">217</th><td><i>// DecreasingSizeRunsHeap collects runs of Alloc and Free calls, sorts them by</i></td></tr>
<tr><th id="218">218</th><td><i>// decreasing size, and delegates the actual calls to another heap algorithm.</i></td></tr>
<tr><th id="219">219</th><td><i>// This greedy heuristic tends to reduce fragmentation for all algorithms.</i></td></tr>
<tr><th id="220">220</th><td><b>class</b> <dfn class="type def" id="xla::DecreasingSizeRunsHeap" title='xla::DecreasingSizeRunsHeap' data-ref="xla::DecreasingSizeRunsHeap">DecreasingSizeRunsHeap</dfn> : <b>public</b> <a class="type" href="#xla::HeapAlgorithm" title='xla::HeapAlgorithm' data-ref="xla::HeapAlgorithm">HeapAlgorithm</a> {</td></tr>
<tr><th id="221">221</th><td> <b>public</b>:</td></tr>
<tr><th id="222">222</th><td>  <dfn class="decl def" id="_ZN3xla22DecreasingSizeRunsHeapC1ESt10unique_ptrINS_13HeapAlgorithmESt14default_deleteIS2_EE" title='xla::DecreasingSizeRunsHeap::DecreasingSizeRunsHeap' data-ref="_ZN3xla22DecreasingSizeRunsHeapC1ESt10unique_ptrINS_13HeapAlgorithmESt14default_deleteIS2_EE">DecreasingSizeRunsHeap</dfn>(<span class="namespace">std::</span><a class="type" href="../../../../../include/c++/5/bits/unique_ptr.h.html#std::unique_ptr" title='std::unique_ptr' data-ref="std::unique_ptr">unique_ptr</a>&lt;<a class="type" href="#xla::HeapAlgorithm" title='xla::HeapAlgorithm' data-ref="xla::HeapAlgorithm">HeapAlgorithm</a>&gt; <dfn class="local col1 decl" id="291algorithm" title='algorithm' data-type='std::unique_ptr&lt;HeapAlgorithm&gt;' data-ref="291algorithm">algorithm</dfn>)</td></tr>
<tr><th id="223">223</th><td>      : <a class="member" href="#xla::DecreasingSizeRunsHeap::algorithm_" title='xla::DecreasingSizeRunsHeap::algorithm_' data-ref="xla::DecreasingSizeRunsHeap::algorithm_">algorithm_</a><a class="ref" href="../../../../../include/c++/5/bits/unique_ptr.h.html#_ZNSt10unique_ptrC1EOSt10unique_ptrIT_T0_E" title='std::unique_ptr::unique_ptr&lt;_Tp, _Dp&gt;' data-ref="_ZNSt10unique_ptrC1EOSt10unique_ptrIT_T0_E">(</a><span class="namespace">std::</span><a class="ref" href="../../../../../include/c++/5/bits/move.h.html#_ZSt4moveOT_" title='std::move' data-ref="_ZSt4moveOT_">move</a>(<span class='refarg'><a class="local col1 ref" href="#291algorithm" title='algorithm' data-ref="291algorithm">algorithm</a></span>)) {}</td></tr>
<tr><th id="224">224</th><td>  <dfn class="virtual decl def" id="_ZN3xla22DecreasingSizeRunsHeapD1Ev" title='xla::DecreasingSizeRunsHeap::~DecreasingSizeRunsHeap' data-ref="_ZN3xla22DecreasingSizeRunsHeapD1Ev">~DecreasingSizeRunsHeap</dfn>() override {}</td></tr>
<tr><th id="225">225</th><td></td></tr>
<tr><th id="226">226</th><td>  <em>void</em> <dfn class="virtual decl" id="_ZN3xla22DecreasingSizeRunsHeap5AllocEPKNS_13LogicalBufferEx" title='xla::DecreasingSizeRunsHeap::Alloc' data-ref="_ZN3xla22DecreasingSizeRunsHeap5AllocEPKNS_13LogicalBufferEx">Alloc</dfn>(<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col2 decl" id="292buffer" title='buffer' data-type='const xla::LogicalBuffer *' data-ref="292buffer">buffer</dfn>, <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="local col3 decl" id="293size" title='size' data-type='int64' data-ref="293size">size</dfn>) override;</td></tr>
<tr><th id="227">227</th><td>  <em>void</em> <dfn class="virtual decl" id="_ZN3xla22DecreasingSizeRunsHeap4FreeEPKNS_13LogicalBufferEx" title='xla::DecreasingSizeRunsHeap::Free' data-ref="_ZN3xla22DecreasingSizeRunsHeap4FreeEPKNS_13LogicalBufferEx">Free</dfn>(<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col4 decl" id="294buffer" title='buffer' data-type='const xla::LogicalBuffer *' data-ref="294buffer">buffer</dfn>, <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="local col5 decl" id="295size" title='size' data-type='int64' data-ref="295size">size</dfn>) override;</td></tr>
<tr><th id="228">228</th><td>  <a class="typedef" href="#xla::HeapAlgorithm::Result" title='xla::HeapAlgorithm::Result' data-type='HeapSimulator::Result' data-ref="xla::HeapAlgorithm::Result">Result</a> <dfn class="virtual decl" id="_ZN3xla22DecreasingSizeRunsHeap6FinishEv" title='xla::DecreasingSizeRunsHeap::Finish' data-ref="_ZN3xla22DecreasingSizeRunsHeap6FinishEv">Finish</dfn>() override;</td></tr>
<tr><th id="229">229</th><td></td></tr>
<tr><th id="230">230</th><td> <b>private</b>:</td></tr>
<tr><th id="231">231</th><td>  <i>// A single Alloc or Free operation that we've buffered in run_.</i></td></tr>
<tr><th id="232">232</th><td>  <b>struct</b> <dfn class="type def" id="xla::DecreasingSizeRunsHeap::Op" title='xla::DecreasingSizeRunsHeap::Op' data-ref="xla::DecreasingSizeRunsHeap::Op">Op</dfn> {</td></tr>
<tr><th id="233">233</th><td>    <em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="decl" id="xla::DecreasingSizeRunsHeap::Op::buffer" title='xla::DecreasingSizeRunsHeap::Op::buffer' data-ref="xla::DecreasingSizeRunsHeap::Op::buffer">buffer</dfn>;</td></tr>
<tr><th id="234">234</th><td>    <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="decl" id="xla::DecreasingSizeRunsHeap::Op::size" title='xla::DecreasingSizeRunsHeap::Op::size' data-ref="xla::DecreasingSizeRunsHeap::Op::size">size</dfn>;</td></tr>
<tr><th id="235">235</th><td>  };</td></tr>
<tr><th id="236">236</th><td></td></tr>
<tr><th id="237">237</th><td>  <i>// Current collection mode; kInit means no ops have been collected yet.</i></td></tr>
<tr><th id="238">238</th><td>  <b>enum</b> <dfn class="type def" id="xla::DecreasingSizeRunsHeap::Mode" title='xla::DecreasingSizeRunsHeap::Mode' data-ref="xla::DecreasingSizeRunsHeap::Mode">Mode</dfn> { <dfn class="enum" id="xla::DecreasingSizeRunsHeap::Mode::kInit" title='xla::DecreasingSizeRunsHeap::Mode::kInit' data-ref="xla::DecreasingSizeRunsHeap::Mode::kInit">kInit</dfn>, <dfn class="enum" id="xla::DecreasingSizeRunsHeap::Mode::kAlloc" title='xla::DecreasingSizeRunsHeap::Mode::kAlloc' data-ref="xla::DecreasingSizeRunsHeap::Mode::kAlloc">kAlloc</dfn>, <dfn class="enum" id="xla::DecreasingSizeRunsHeap::Mode::kFree" title='xla::DecreasingSizeRunsHeap::Mode::kFree' data-ref="xla::DecreasingSizeRunsHeap::Mode::kFree">kFree</dfn> };</td></tr>
<tr><th id="239">239</th><td></td></tr>
<tr><th id="240">240</th><td>  <em>void</em> <dfn class="decl" id="_ZN3xla22DecreasingSizeRunsHeap7SetModeENS0_4ModeE" title='xla::DecreasingSizeRunsHeap::SetMode' data-ref="_ZN3xla22DecreasingSizeRunsHeap7SetModeENS0_4ModeE">SetMode</dfn>(<a class="type" href="#xla::DecreasingSizeRunsHeap::Mode" title='xla::DecreasingSizeRunsHeap::Mode' data-ref="xla::DecreasingSizeRunsHeap::Mode">Mode</a> <dfn class="local col6 decl" id="296mode" title='mode' data-type='xla::DecreasingSizeRunsHeap::Mode' data-ref="296mode">mode</dfn>);</td></tr>
<tr><th id="241">241</th><td>  <em>void</em> <dfn class="decl" id="_ZN3xla22DecreasingSizeRunsHeap15CallAndDrainRunEv" title='xla::DecreasingSizeRunsHeap::CallAndDrainRun' data-ref="_ZN3xla22DecreasingSizeRunsHeap15CallAndDrainRunEv">CallAndDrainRun</dfn>();</td></tr>
<tr><th id="242">242</th><td></td></tr>
<tr><th id="243">243</th><td>  <em>const</em> <span class="namespace">std::</span><a class="type" href="../../../../../include/c++/5/bits/unique_ptr.h.html#std::unique_ptr" title='std::unique_ptr' data-ref="std::unique_ptr">unique_ptr</a>&lt;<a class="type" href="#xla::HeapAlgorithm" title='xla::HeapAlgorithm' data-ref="xla::HeapAlgorithm">HeapAlgorithm</a>&gt; <dfn class="decl" id="xla::DecreasingSizeRunsHeap::algorithm_" title='xla::DecreasingSizeRunsHeap::algorithm_' data-ref="xla::DecreasingSizeRunsHeap::algorithm_">algorithm_</dfn>;</td></tr>
<tr><th id="244">244</th><td>  <span class="namespace">std::</span><a class="type" href="../../../../../include/c++/5/bits/stl_vector.h.html#std::vector" title='std::vector' data-ref="std::vector">vector</a>&lt;<a class="type" href="#xla::DecreasingSizeRunsHeap::Op" title='xla::DecreasingSizeRunsHeap::Op' data-ref="xla::DecreasingSizeRunsHeap::Op">Op</a>&gt; <dfn class="decl" id="xla::DecreasingSizeRunsHeap::run_" title='xla::DecreasingSizeRunsHeap::run_' data-ref="xla::DecreasingSizeRunsHeap::run_">run_</dfn>;</td></tr>
<tr><th id="245">245</th><td>  <a class="type" href="#xla::DecreasingSizeRunsHeap::Mode" title='xla::DecreasingSizeRunsHeap::Mode' data-ref="xla::DecreasingSizeRunsHeap::Mode">Mode</a> <dfn class="decl" id="xla::DecreasingSizeRunsHeap::mode_" title='xla::DecreasingSizeRunsHeap::mode_' data-ref="xla::DecreasingSizeRunsHeap::mode_">mode_</dfn> = <a class="enum" href="#xla::DecreasingSizeRunsHeap::Mode::kInit" title='xla::DecreasingSizeRunsHeap::Mode::kInit' data-ref="xla::DecreasingSizeRunsHeap::Mode::kInit">kInit</a>;</td></tr>
<tr><th id="246">246</th><td>};</td></tr>
<tr><th id="247">247</th><td></td></tr>
<tr><th id="248">248</th><td><i>// LazyBestFitHeap is a variant of the traditional best-fit heap.  This is a</i></td></tr>
<tr><th id="249">249</th><td><i>// greedy heuristic, based on the idea that delaying offset assignment helps</i></td></tr>
<tr><th id="250">250</th><td><i>// reduce fragmentation.  Here's an example of a "bad" offset assignment, where</i></td></tr>
<tr><th id="251">251</th><td><i>// a tiny buffer A prevents adjacent free chunks from being coalesced:</i></td></tr>
<tr><th id="252">252</th><td><i>//    BAD: |  free  |A|  free  |</i></td></tr>
<tr><th id="253">253</th><td><i>// If we could have delayed the assignment of A, we might have ended up with:</i></td></tr>
<tr><th id="254">254</th><td><i>//   GOOD: |      free       |A|</i></td></tr>
<tr><th id="255">255</th><td><i>//</i></td></tr>
<tr><th id="256">256</th><td><i>// In general it's actually hard to say whether GOOD is better than BAD; the</i></td></tr>
<tr><th id="257">257</th><td><i>// heuristic we use is we try to leave large contiguous chunks free, and we try</i></td></tr>
<tr><th id="258">258</th><td><i>// to avoid growing the overall heap size unless necessary.</i></td></tr>
<tr><th id="259">259</th><td><i>//</i></td></tr>
<tr><th id="260">260</th><td><i>// Just like regular best-fit, in Alloc we look for the smallest free chunk that</i></td></tr>
<tr><th id="261">261</th><td><i>// fits the requested size.  Unlike regular best-fit, we postpone offset</i></td></tr>
<tr><th id="262">262</th><td><i>// assignment for buffers that cannot re-use existing free chunks (and force us</i></td></tr>
<tr><th id="263">263</th><td><i>// to grow the heap); these buffers are "lazily" assigned offsets in Free.</i></td></tr>
<tr><th id="264">264</th><td><b>class</b> <dfn class="type def" id="xla::LazyBestFitHeap" title='xla::LazyBestFitHeap' data-ref="xla::LazyBestFitHeap">LazyBestFitHeap</dfn> : <b>public</b> <a class="type" href="#xla::HeapAlgorithm" title='xla::HeapAlgorithm' data-ref="xla::HeapAlgorithm">HeapAlgorithm</a> {</td></tr>
<tr><th id="265">265</th><td> <b>public</b>:</td></tr>
<tr><th id="266">266</th><td>  <dfn class="decl def" id="_ZN3xla15LazyBestFitHeapC1Ex" title='xla::LazyBestFitHeap::LazyBestFitHeap' data-ref="_ZN3xla15LazyBestFitHeapC1Ex">LazyBestFitHeap</dfn>(<a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="local col7 decl" id="297alignment" title='alignment' data-type='int64' data-ref="297alignment">alignment</dfn>) : <a class="member" href="#xla::LazyBestFitHeap::alignment_" title='xla::LazyBestFitHeap::alignment_' data-ref="xla::LazyBestFitHeap::alignment_">alignment_</a>(<a class="local col7 ref" href="#297alignment" title='alignment' data-ref="297alignment">alignment</a>) {}</td></tr>
<tr><th id="267">267</th><td>  <dfn class="virtual decl def" id="_ZN3xla15LazyBestFitHeapD1Ev" title='xla::LazyBestFitHeap::~LazyBestFitHeap' data-ref="_ZN3xla15LazyBestFitHeapD1Ev">~LazyBestFitHeap</dfn>() override {}</td></tr>
<tr><th id="268">268</th><td></td></tr>
<tr><th id="269">269</th><td>  <em>void</em> <dfn class="virtual decl" id="_ZN3xla15LazyBestFitHeap5AllocEPKNS_13LogicalBufferEx" title='xla::LazyBestFitHeap::Alloc' data-ref="_ZN3xla15LazyBestFitHeap5AllocEPKNS_13LogicalBufferEx">Alloc</dfn>(<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col8 decl" id="298buffer" title='buffer' data-type='const xla::LogicalBuffer *' data-ref="298buffer">buffer</dfn>, <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="local col9 decl" id="299size" title='size' data-type='int64' data-ref="299size">size</dfn>) override;</td></tr>
<tr><th id="270">270</th><td>  <em>void</em> <dfn class="virtual decl" id="_ZN3xla15LazyBestFitHeap4FreeEPKNS_13LogicalBufferEx" title='xla::LazyBestFitHeap::Free' data-ref="_ZN3xla15LazyBestFitHeap4FreeEPKNS_13LogicalBufferEx">Free</dfn>(<em>const</em> <a class="type" href="logical_buffer.h.html#xla::LogicalBuffer" title='xla::LogicalBuffer' data-ref="xla::LogicalBuffer">LogicalBuffer</a>* <dfn class="local col0 decl" id="300buffer" title='buffer' data-type='const xla::LogicalBuffer *' data-ref="300buffer">buffer</dfn>, <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="local col1 decl" id="301size" title='size' data-type='int64' data-ref="301size">size</dfn>) override;</td></tr>
<tr><th id="271">271</th><td>  <a class="typedef" href="#xla::HeapAlgorithm::Result" title='xla::HeapAlgorithm::Result' data-type='HeapSimulator::Result' data-ref="xla::HeapAlgorithm::Result">Result</a> <dfn class="virtual decl" id="_ZN3xla15LazyBestFitHeap6FinishEv" title='xla::LazyBestFitHeap::Finish' data-ref="_ZN3xla15LazyBestFitHeap6FinishEv">Finish</dfn>() override;</td></tr>
<tr><th id="272">272</th><td></td></tr>
<tr><th id="273">273</th><td> <b>private</b>:</td></tr>
<tr><th id="274">274</th><td>  <i>// Sentry value used to indicate a chunk that wasn't assigned an offset in</i></td></tr>
<tr><th id="275">275</th><td><i>  // Alloc, and will instead be assigned an offset in Free.</i></td></tr>
<tr><th id="276">276</th><td>  <b>enum</b> { <dfn class="enum" id="xla::LazyBestFitHeap::kLazyAllocOffset" title='xla::LazyBestFitHeap::kLazyAllocOffset' data-ref="xla::LazyBestFitHeap::kLazyAllocOffset">kLazyAllocOffset</dfn> = -<var>1</var> };</td></tr>
<tr><th id="277">277</th><td></td></tr>
<tr><th id="278">278</th><td>  <b>struct</b> <dfn class="type def" id="xla::LazyBestFitHeap::OrderChunkByIncreasingSize" title='xla::LazyBestFitHeap::OrderChunkByIncreasingSize' data-ref="xla::LazyBestFitHeap::OrderChunkByIncreasingSize">OrderChunkByIncreasingSize</dfn> {</td></tr>
<tr><th id="279">279</th><td>    <em>bool</em> <dfn class="decl def" id="_ZNK3xla15LazyBestFitHeap26OrderChunkByIncreasingSizeclERKNS_13HeapSimulator5ChunkES5_" title='xla::LazyBestFitHeap::OrderChunkByIncreasingSize::operator()' data-ref="_ZNK3xla15LazyBestFitHeap26OrderChunkByIncreasingSizeclERKNS_13HeapSimulator5ChunkES5_"><b>operator</b>()</dfn>(<em>const</em> <a class="typedef" href="#xla::HeapAlgorithm::Chunk" title='xla::HeapAlgorithm::Chunk' data-type='HeapSimulator::Chunk' data-ref="xla::HeapAlgorithm::Chunk">Chunk</a>&amp; <dfn class="local col2 decl" id="302a" title='a' data-type='const Chunk &amp;' data-ref="302a">a</dfn>, <em>const</em> <a class="typedef" href="#xla::HeapAlgorithm::Chunk" title='xla::HeapAlgorithm::Chunk' data-type='HeapSimulator::Chunk' data-ref="xla::HeapAlgorithm::Chunk">Chunk</a>&amp; <dfn class="local col3 decl" id="303b" title='b' data-type='const Chunk &amp;' data-ref="303b">b</dfn>) <em>const</em> {</td></tr>
<tr><th id="280">280</th><td>      <b>if</b> (<a class="local col2 ref" href="#302a" title='a' data-ref="302a">a</a>.<a class="ref" href="#xla::HeapSimulator::Chunk::size" title='xla::HeapSimulator::Chunk::size' data-ref="xla::HeapSimulator::Chunk::size">size</a> != <a class="local col3 ref" href="#303b" title='b' data-ref="303b">b</a>.<a class="ref" href="#xla::HeapSimulator::Chunk::size" title='xla::HeapSimulator::Chunk::size' data-ref="xla::HeapSimulator::Chunk::size">size</a>) <b>return</b> <a class="local col2 ref" href="#302a" title='a' data-ref="302a">a</a>.<a class="ref" href="#xla::HeapSimulator::Chunk::size" title='xla::HeapSimulator::Chunk::size' data-ref="xla::HeapSimulator::Chunk::size">size</a> &lt; <a class="local col3 ref" href="#303b" title='b' data-ref="303b">b</a>.<a class="ref" href="#xla::HeapSimulator::Chunk::size" title='xla::HeapSimulator::Chunk::size' data-ref="xla::HeapSimulator::Chunk::size">size</a>;</td></tr>
<tr><th id="281">281</th><td>      <b>return</b> <a class="local col2 ref" href="#302a" title='a' data-ref="302a">a</a>.<a class="ref" href="#xla::HeapSimulator::Chunk::offset" title='xla::HeapSimulator::Chunk::offset' data-ref="xla::HeapSimulator::Chunk::offset">offset</a> &lt; <a class="local col3 ref" href="#303b" title='b' data-ref="303b">b</a>.<a class="ref" href="#xla::HeapSimulator::Chunk::offset" title='xla::HeapSimulator::Chunk::offset' data-ref="xla::HeapSimulator::Chunk::offset">offset</a>;</td></tr>
<tr><th id="282">282</th><td>    }</td></tr>
<tr><th id="283">283</th><td>  };</td></tr>
<tr><th id="284">284</th><td></td></tr>
<tr><th id="285">285</th><td>  <em>void</em> <dfn class="decl" id="_ZN3xla15LazyBestFitHeap12AddFreeChunkExx" title='xla::LazyBestFitHeap::AddFreeChunk' data-ref="_ZN3xla15LazyBestFitHeap12AddFreeChunkExx">AddFreeChunk</dfn>(<a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="local col4 decl" id="304offset" title='offset' data-type='int64' data-ref="304offset">offset</dfn>, <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="local col5 decl" id="305size" title='size' data-type='int64' data-ref="305size">size</dfn>);</td></tr>
<tr><th id="286">286</th><td></td></tr>
<tr><th id="287">287</th><td>  <em>const</em> <a class="typedef" href="../../../core/platform/default/integral_types.h.html#tensorflow::int64" title='tensorflow::int64' data-type='long long' data-ref="tensorflow::int64">int64</a> <dfn class="decl" id="xla::LazyBestFitHeap::alignment_" title='xla::LazyBestFitHeap::alignment_' data-ref="xla::LazyBestFitHeap::alignment_">alignment_</dfn>;</td></tr>
<tr><th id="288">288</th><td>  <a class="typedef" href="#xla::HeapAlgorithm::Result" title='xla::HeapAlgorithm::Result' data-type='HeapSimulator::Result' data-ref="xla::HeapAlgorithm::Result">Result</a> <dfn class="decl" id="xla::LazyBestFitHeap::result_" title='xla::LazyBestFitHeap::result_' data-ref="xla::LazyBestFitHeap::result_">result_</dfn>;</td></tr>
<tr><th id="289">289</th><td></td></tr>
<tr><th id="290">290</th><td>  <i>// Maintain the set of free chunks, ordered by increasing size.</i></td></tr>
<tr><th id="291">291</th><td>  <span class="namespace">std::</span><a class="type" href="../../../../../include/c++/5/bits/stl_set.h.html#std::set" title='std::set' data-ref="std::set">set</a>&lt;<a class="typedef" href="#xla::HeapAlgorithm::Chunk" title='xla::HeapAlgorithm::Chunk' data-type='HeapSimulator::Chunk' data-ref="xla::HeapAlgorithm::Chunk">Chunk</a>, <a class="type" href="#xla::LazyBestFitHeap::OrderChunkByIncreasingSize" title='xla::LazyBestFitHeap::OrderChunkByIncreasingSize' data-ref="xla::LazyBestFitHeap::OrderChunkByIncreasingSize">OrderChunkByIncreasingSize</a>&gt; <dfn class="decl" id="xla::LazyBestFitHeap::free_" title='xla::LazyBestFitHeap::free_' data-ref="xla::LazyBestFitHeap::free_">free_</dfn>;</td></tr>
<tr><th id="292">292</th><td>};</td></tr>
<tr><th id="293">293</th><td></td></tr>
<tr><th id="294">294</th><td>}  <i>// namespace xla</i></td></tr>
<tr><th id="295">295</th><td></td></tr>
<tr><th id="296">296</th><td><u>#<span data-ppcond="16">endif</span>  // TENSORFLOW_COMPILER_XLA_SERVICE_HEAP_SIMULATOR_H_</u></td></tr>
<tr><th id="297">297</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='buffer_assignment.cc.html'>tensorflow/tensorflow/compiler/xla/service/buffer_assignment.cc</a><br/>Generated on <em>2018-Aug-20</em> from project tensorflow revision <em>v1.8</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
