<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>context.h source code [tensorflow/tensorflow/contrib/lite/context.h] - Woboq Code Browser</title>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'tensorflow/tensorflow/contrib/lite/context.h'; var root_path = '../../../..'; var data_path = 'https://code.woboq.org/data';</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../..'>tensorflow</a>/<a href='../..'>tensorflow</a>/<a href='..'>contrib</a>/<a href='./'>lite</a>/<a href='context.h.html'>context.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.</i></td></tr>
<tr><th id="2">2</th><td><i></i></td></tr>
<tr><th id="3">3</th><td><i>Licensed under the Apache License, Version 2.0 (the "License");</i></td></tr>
<tr><th id="4">4</th><td><i>you may not use this file except in compliance with the License.</i></td></tr>
<tr><th id="5">5</th><td><i>You may obtain a copy of the License at</i></td></tr>
<tr><th id="6">6</th><td><i></i></td></tr>
<tr><th id="7">7</th><td><i>    <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></i></td></tr>
<tr><th id="8">8</th><td><i></i></td></tr>
<tr><th id="9">9</th><td><i>Unless required by applicable law or agreed to in writing, software</i></td></tr>
<tr><th id="10">10</th><td><i>distributed under the License is distributed on an "AS IS" BASIS,</i></td></tr>
<tr><th id="11">11</th><td><i>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i></td></tr>
<tr><th id="12">12</th><td><i>See the License for the specific language governing permissions and</i></td></tr>
<tr><th id="13">13</th><td><i>limitations under the License.</i></td></tr>
<tr><th id="14">14</th><td><i>==============================================================================*/</i></td></tr>
<tr><th id="15">15</th><td><i>// This file defines a C API for implementing operations in tflite.</i></td></tr>
<tr><th id="16">16</th><td><i>// These operations can be defined using c++ but the interface between</i></td></tr>
<tr><th id="17">17</th><td><i>// the interpreter and the operations are C.</i></td></tr>
<tr><th id="18">18</th><td><i>//</i></td></tr>
<tr><th id="19">19</th><td><i>// Summary of abstractions</i></td></tr>
<tr><th id="20">20</th><td><i>// TF_LITE_ENSURE - Self-sufficient error checking</i></td></tr>
<tr><th id="21">21</th><td><i>// TfLiteStatus - Status reporting</i></td></tr>
<tr><th id="22">22</th><td><i>// TfLiteIntArray - stores tensor shapes (dims),</i></td></tr>
<tr><th id="23">23</th><td><i>// TfLiteContext - allows an op to access the tensors</i></td></tr>
<tr><th id="24">24</th><td><i>// TfLiteTensor - tensor (a multidimensional array)</i></td></tr>
<tr><th id="25">25</th><td><i>// TfLiteNode - a single node or operation</i></td></tr>
<tr><th id="26">26</th><td><i>// TfLiteRegistration - the implementation of a conceptual operation.</i></td></tr>
<tr><th id="27">27</th><td><i>//</i></td></tr>
<tr><th id="28">28</th><td><i>// Some abstractions in this file are created and managed by Interpreter.</i></td></tr>
<tr><th id="29">29</th><td><u>#<span data-ppcond="29">ifndef</span> <span class="macro" data-ref="_M/TENSORFLOW_CONTRIB_LITE_CONTEXT_H_">TENSORFLOW_CONTRIB_LITE_CONTEXT_H_</span></u></td></tr>
<tr><th id="30">30</th><td><u>#define <dfn class="macro" id="_M/TENSORFLOW_CONTRIB_LITE_CONTEXT_H_" data-ref="_M/TENSORFLOW_CONTRIB_LITE_CONTEXT_H_">TENSORFLOW_CONTRIB_LITE_CONTEXT_H_</dfn></u></td></tr>
<tr><th id="31">31</th><td></td></tr>
<tr><th id="32">32</th><td><u>#include &lt;stdbool.h&gt;</u></td></tr>
<tr><th id="33">33</th><td><u>#include &lt;stdint.h&gt;</u></td></tr>
<tr><th id="34">34</th><td><u>#include <a href="../../../../include/stdlib.h.html">&lt;stdlib.h&gt;</a></u></td></tr>
<tr><th id="35">35</th><td></td></tr>
<tr><th id="36">36</th><td><u>#<span data-ppcond="36">ifdef</span> <span class="macro" data-ref="_M/__cplusplus">__cplusplus</span></u></td></tr>
<tr><th id="37">37</th><td><b>extern</b> <q>"C"</q> {</td></tr>
<tr><th id="38">38</th><td><u>#<span data-ppcond="36">endif</span>  // __cplusplus</u></td></tr>
<tr><th id="39">39</th><td></td></tr>
<tr><th id="40">40</th><td><b>typedef</b> <b>enum</b> { <dfn class="enum" id="kTfLiteOk" title='kTfLiteOk' data-ref="kTfLiteOk">kTfLiteOk</dfn> = <var>0</var>, <dfn class="enum" id="kTfLiteError" title='kTfLiteError' data-ref="kTfLiteError">kTfLiteError</dfn> = <var>1</var> } <dfn class="typedef" id="TfLiteStatus" title='TfLiteStatus' data-type='enum TfLiteStatus' data-ref="TfLiteStatus">TfLiteStatus</dfn>;</td></tr>
<tr><th id="41">41</th><td></td></tr>
<tr><th id="42">42</th><td><i>// Forward declare so GetNode can use this is in Context.</i></td></tr>
<tr><th id="43">43</th><td><b>typedef</b> <b>struct</b> <a class="type" href="#_TfLiteRegistration" title='_TfLiteRegistration' data-ref="_TfLiteRegistration">_TfLiteRegistration</a> <dfn class="typedef" id="TfLiteRegistration" title='TfLiteRegistration' data-type='struct _TfLiteRegistration' data-ref="TfLiteRegistration">TfLiteRegistration</dfn>;</td></tr>
<tr><th id="44">44</th><td><b>typedef</b> <b>struct</b> <a class="type" href="#_TfLiteDelegate" title='_TfLiteDelegate' data-ref="_TfLiteDelegate">_TfLiteDelegate</a> <dfn class="typedef" id="TfLiteDelegate" title='TfLiteDelegate' data-type='struct _TfLiteDelegate' data-ref="TfLiteDelegate">TfLiteDelegate</dfn>;</td></tr>
<tr><th id="45">45</th><td></td></tr>
<tr><th id="46">46</th><td><u>#define <dfn class="macro" id="_M/kOptionalTensor" data-ref="_M/kOptionalTensor">kOptionalTensor</dfn> (-1)</u></td></tr>
<tr><th id="47">47</th><td></td></tr>
<tr><th id="48">48</th><td><i>// Fixed size list of integers. Used for dimensions and inputs/outputs tensor</i></td></tr>
<tr><th id="49">49</th><td><i>// indices</i></td></tr>
<tr><th id="50">50</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="51">51</th><td>  <em>int</em> <dfn class="decl" id="(anonymous)::size" title='(anonymous struct)::size' data-ref="(anonymous)::size">size</dfn>;</td></tr>
<tr><th id="52">52</th><td><i>// gcc 6.1+ have a bug where flexible members aren't properly handled</i></td></tr>
<tr><th id="53">53</th><td><i>// <a href="https://github.com/google/re2/commit/b94b7cd42e9f02673cd748c1ac1d16db4052514c">https://github.com/google/re2/commit/b94b7cd42e9f02673cd748c1ac1d16db4052514c</a></i></td></tr>
<tr><th id="54">54</th><td><u>#<span data-ppcond="54">if</span> !defined(<span class="macro" data-ref="_M/__clang__">__clang__</span>) &amp;&amp; defined(<span class="macro" data-ref="_M/__GNUC__">__GNUC__</span>) &amp;&amp; <span class="macro" title="4" data-ref="_M/__GNUC__">__GNUC__</span> == 6 &amp;&amp; \</u></td></tr>
<tr><th id="55">55</th><td><u>    <span class="macro" title="2" data-ref="_M/__GNUC_MINOR__">__GNUC_MINOR__</span> &gt;= 1</u></td></tr>
<tr><th id="56">56</th><td>  <em>int</em> data[<var>0</var>];</td></tr>
<tr><th id="57">57</th><td><u>#<span data-ppcond="54">else</span></u></td></tr>
<tr><th id="58">58</th><td>  <em>int</em> <dfn class="decl" id="(anonymous)::data" title='(anonymous struct)::data' data-ref="(anonymous)::data">data</dfn>[];</td></tr>
<tr><th id="59">59</th><td><u>#<span data-ppcond="54">endif</span></u></td></tr>
<tr><th id="60">60</th><td>} <dfn class="typedef" id="TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</dfn>;</td></tr>
<tr><th id="61">61</th><td></td></tr>
<tr><th id="62">62</th><td><i>// Given the size (number of elements) in a TfLiteIntArray, calculate its size</i></td></tr>
<tr><th id="63">63</th><td><i>// in bytes.</i></td></tr>
<tr><th id="64">64</th><td><em>int</em> <dfn class="decl" id="TfLiteIntArrayGetSizeInBytes" title='TfLiteIntArrayGetSizeInBytes' data-ref="TfLiteIntArrayGetSizeInBytes">TfLiteIntArrayGetSizeInBytes</dfn>(<em>int</em> <dfn class="local col8 decl" id="48size" title='size' data-type='int' data-ref="48size">size</dfn>);</td></tr>
<tr><th id="65">65</th><td></td></tr>
<tr><th id="66">66</th><td><i>// Create a array of a given `size` (uninitialized entries).</i></td></tr>
<tr><th id="67">67</th><td><i>// This returns a pointer, that you must free using TfLiteIntArrayFree().</i></td></tr>
<tr><th id="68">68</th><td><a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="decl" id="TfLiteIntArrayCreate" title='TfLiteIntArrayCreate' data-ref="TfLiteIntArrayCreate">TfLiteIntArrayCreate</dfn>(<em>int</em> <dfn class="local col9 decl" id="49size" title='size' data-type='int' data-ref="49size">size</dfn>);</td></tr>
<tr><th id="69">69</th><td></td></tr>
<tr><th id="70">70</th><td><i>// Check if two tensors are equal. Returns 1 if they are equal, 0 otherwise.</i></td></tr>
<tr><th id="71">71</th><td><em>int</em> <dfn class="decl" id="TfLiteIntArrayEqual" title='TfLiteIntArrayEqual' data-ref="TfLiteIntArrayEqual">TfLiteIntArrayEqual</dfn>(<a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="local col0 decl" id="50a" title='a' data-type='TfLiteIntArray *' data-ref="50a">a</dfn>, <a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="local col1 decl" id="51b" title='b' data-type='TfLiteIntArray *' data-ref="51b">b</dfn>);</td></tr>
<tr><th id="72">72</th><td></td></tr>
<tr><th id="73">73</th><td><i>// Create a copy of an array passed as `src`.</i></td></tr>
<tr><th id="74">74</th><td><i>// You are expected to free memory with TfLiteIntArrayFree</i></td></tr>
<tr><th id="75">75</th><td><a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="decl" id="TfLiteIntArrayCopy" title='TfLiteIntArrayCopy' data-ref="TfLiteIntArrayCopy">TfLiteIntArrayCopy</dfn>(<a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="local col2 decl" id="52src" title='src' data-type='TfLiteIntArray *' data-ref="52src">src</dfn>);</td></tr>
<tr><th id="76">76</th><td></td></tr>
<tr><th id="77">77</th><td><i>// Free memory of array `v`.</i></td></tr>
<tr><th id="78">78</th><td><em>void</em> <dfn class="decl" id="TfLiteIntArrayFree" title='TfLiteIntArrayFree' data-ref="TfLiteIntArrayFree">TfLiteIntArrayFree</dfn>(<a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="local col3 decl" id="53v" title='v' data-type='TfLiteIntArray *' data-ref="53v">v</dfn>);</td></tr>
<tr><th id="79">79</th><td></td></tr>
<tr><th id="80">80</th><td><i>// Since we must not depend on any libraries, define a minimal subset of</i></td></tr>
<tr><th id="81">81</th><td><i>// error macros while avoiding names that have pre-conceived meanings like</i></td></tr>
<tr><th id="82">82</th><td><i>// assert and check.</i></td></tr>
<tr><th id="83">83</th><td><i></i></td></tr>
<tr><th id="84">84</th><td><i>// Check whether value is true, and if not return kTfLiteError from</i></td></tr>
<tr><th id="85">85</th><td><i>// the current function (and report the error string msg).</i></td></tr>
<tr><th id="86">86</th><td><u>#define <dfn class="macro" id="_M/TF_LITE_ENSURE_MSG" data-ref="_M/TF_LITE_ENSURE_MSG">TF_LITE_ENSURE_MSG</dfn>(context, value, msg)            \</u></td></tr>
<tr><th id="87">87</th><td><u>  do {                                                     \</u></td></tr>
<tr><th id="88">88</th><td><u>    if (!(value)) {                                        \</u></td></tr>
<tr><th id="89">89</th><td><u>      (context)-&gt;ReportError((context), __FILE__ " " msg); \</u></td></tr>
<tr><th id="90">90</th><td><u>      return kTfLiteError;                                 \</u></td></tr>
<tr><th id="91">91</th><td><u>    }                                                      \</u></td></tr>
<tr><th id="92">92</th><td><u>  } while (0)</u></td></tr>
<tr><th id="93">93</th><td></td></tr>
<tr><th id="94">94</th><td><i>// Check whether the value `a` is true, and if not return kTfLiteError from</i></td></tr>
<tr><th id="95">95</th><td><i>// the current function, while also reporting the location of the error.</i></td></tr>
<tr><th id="96">96</th><td><u>#define <dfn class="macro" id="_M/TF_LITE_ENSURE" data-ref="_M/TF_LITE_ENSURE">TF_LITE_ENSURE</dfn>(context, a)                                          \</u></td></tr>
<tr><th id="97">97</th><td><u>  do {                                                                      \</u></td></tr>
<tr><th id="98">98</th><td><u>    if (!(a)) {                                                             \</u></td></tr>
<tr><th id="99">99</th><td><u>      (context)-&gt;ReportError((context), "%s:%d %s was not true.", __FILE__, \</u></td></tr>
<tr><th id="100">100</th><td><u>                             __LINE__, #a);                                 \</u></td></tr>
<tr><th id="101">101</th><td><u>      return kTfLiteError;                                                  \</u></td></tr>
<tr><th id="102">102</th><td><u>    }                                                                       \</u></td></tr>
<tr><th id="103">103</th><td><u>  } while (0)</u></td></tr>
<tr><th id="104">104</th><td></td></tr>
<tr><th id="105">105</th><td><u>#define <dfn class="macro" id="_M/TF_LITE_ENSURE_STATUS" data-ref="_M/TF_LITE_ENSURE_STATUS">TF_LITE_ENSURE_STATUS</dfn>(a) \</u></td></tr>
<tr><th id="106">106</th><td><u>  do {                           \</u></td></tr>
<tr><th id="107">107</th><td><u>    if ((a) != kTfLiteOk) {      \</u></td></tr>
<tr><th id="108">108</th><td><u>      return kTfLiteError;       \</u></td></tr>
<tr><th id="109">109</th><td><u>    }                            \</u></td></tr>
<tr><th id="110">110</th><td><u>  } while (0)</u></td></tr>
<tr><th id="111">111</th><td></td></tr>
<tr><th id="112">112</th><td><i>// Check whether the value `a == b` is true, and if not return kTfLiteError from</i></td></tr>
<tr><th id="113">113</th><td><i>// the current function, while also reporting the location of the error.</i></td></tr>
<tr><th id="114">114</th><td><i>// `a` and `b` may be evaluated more than once, so no side effects or</i></td></tr>
<tr><th id="115">115</th><td><i>// extremely expensive computations should be done.</i></td></tr>
<tr><th id="116">116</th><td><u>#define <dfn class="macro" id="_M/TF_LITE_ENSURE_EQ" data-ref="_M/TF_LITE_ENSURE_EQ">TF_LITE_ENSURE_EQ</dfn>(context, a, b)                                       \</u></td></tr>
<tr><th id="117">117</th><td><u>  do {                                                                         \</u></td></tr>
<tr><th id="118">118</th><td><u>    if ((a) != (b)) {                                                          \</u></td></tr>
<tr><th id="119">119</th><td><u>      (context)-&gt;ReportError((context), "%s:%d %s != %s (%d != %d)", __FILE__, \</u></td></tr>
<tr><th id="120">120</th><td><u>                             __LINE__, #a, #b, (a), (b));                      \</u></td></tr>
<tr><th id="121">121</th><td><u>      return kTfLiteError;                                                     \</u></td></tr>
<tr><th id="122">122</th><td><u>    }                                                                          \</u></td></tr>
<tr><th id="123">123</th><td><u>  } while (0)</u></td></tr>
<tr><th id="124">124</th><td></td></tr>
<tr><th id="125">125</th><td><u>#define <dfn class="macro" id="_M/TF_LITE_ENSURE_OK" data-ref="_M/TF_LITE_ENSURE_OK">TF_LITE_ENSURE_OK</dfn>(context, status) \</u></td></tr>
<tr><th id="126">126</th><td><u>  do {                                     \</u></td></tr>
<tr><th id="127">127</th><td><u>    if ((status) != kTfLiteOk) {           \</u></td></tr>
<tr><th id="128">128</th><td><u>      return status;                       \</u></td></tr>
<tr><th id="129">129</th><td><u>    }                                      \</u></td></tr>
<tr><th id="130">130</th><td><u>  } while (0)</u></td></tr>
<tr><th id="131">131</th><td></td></tr>
<tr><th id="132">132</th><td><i>// Types supported by tensor</i></td></tr>
<tr><th id="133">133</th><td><b>typedef</b> <b>enum</b> {</td></tr>
<tr><th id="134">134</th><td>  <dfn class="enum" id="kTfLiteNoType" title='kTfLiteNoType' data-ref="kTfLiteNoType">kTfLiteNoType</dfn> = <var>0</var>,</td></tr>
<tr><th id="135">135</th><td>  <dfn class="enum" id="kTfLiteFloat32" title='kTfLiteFloat32' data-ref="kTfLiteFloat32">kTfLiteFloat32</dfn> = <var>1</var>,</td></tr>
<tr><th id="136">136</th><td>  <dfn class="enum" id="kTfLiteInt32" title='kTfLiteInt32' data-ref="kTfLiteInt32">kTfLiteInt32</dfn> = <var>2</var>,</td></tr>
<tr><th id="137">137</th><td>  <dfn class="enum" id="kTfLiteUInt8" title='kTfLiteUInt8' data-ref="kTfLiteUInt8">kTfLiteUInt8</dfn> = <var>3</var>,</td></tr>
<tr><th id="138">138</th><td>  <dfn class="enum" id="kTfLiteInt64" title='kTfLiteInt64' data-ref="kTfLiteInt64">kTfLiteInt64</dfn> = <var>4</var>,</td></tr>
<tr><th id="139">139</th><td>  <dfn class="enum" id="kTfLiteString" title='kTfLiteString' data-ref="kTfLiteString">kTfLiteString</dfn> = <var>5</var>,</td></tr>
<tr><th id="140">140</th><td>} <dfn class="typedef" id="TfLiteType" title='TfLiteType' data-type='enum TfLiteType' data-ref="TfLiteType">TfLiteType</dfn>;</td></tr>
<tr><th id="141">141</th><td></td></tr>
<tr><th id="142">142</th><td><i>// Parameters for asymmetric quantization. Quantized values can be converted</i></td></tr>
<tr><th id="143">143</th><td><i>// back to float using:</i></td></tr>
<tr><th id="144">144</th><td><i>//    real_value = scale * (quantized_value - zero_point);</i></td></tr>
<tr><th id="145">145</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="146">146</th><td>  <em>float</em> <dfn class="decl" id="(anonymous)::scale" title='(anonymous struct)::scale' data-ref="(anonymous)::scale">scale</dfn>;</td></tr>
<tr><th id="147">147</th><td>  <a class="typedef" href="../../../../include/x86_64-linux-gnu/sys/types.h.html#196" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="decl" id="(anonymous)::zero_point" title='(anonymous struct)::zero_point' data-ref="(anonymous)::zero_point">zero_point</dfn>;</td></tr>
<tr><th id="148">148</th><td>} <dfn class="typedef" id="TfLiteQuantizationParams" title='TfLiteQuantizationParams' data-type='struct TfLiteQuantizationParams' data-ref="TfLiteQuantizationParams">TfLiteQuantizationParams</dfn>;</td></tr>
<tr><th id="149">149</th><td></td></tr>
<tr><th id="150">150</th><td><i>// A union of points that points to memory for a given tensor.</i></td></tr>
<tr><th id="151">151</th><td><b>typedef</b> <b>union</b> {</td></tr>
<tr><th id="152">152</th><td>  <em>int</em>* <dfn class="decl" id="(anonymous)::i32" title='(anonymous union)::i32' data-ref="(anonymous)::i32">i32</dfn>;</td></tr>
<tr><th id="153">153</th><td>  <a class="typedef" href="../../../../include/x86_64-linux-gnu/sys/types.h.html#197" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a>* <dfn class="decl" id="(anonymous)::i64" title='(anonymous union)::i64' data-ref="(anonymous)::i64">i64</dfn>;</td></tr>
<tr><th id="154">154</th><td>  <em>float</em>* <dfn class="decl" id="(anonymous)::f" title='(anonymous union)::f' data-ref="(anonymous)::f">f</dfn>;</td></tr>
<tr><th id="155">155</th><td>  <em>char</em>* <dfn class="decl" id="(anonymous)::raw" title='(anonymous union)::raw' data-ref="(anonymous)::raw">raw</dfn>;</td></tr>
<tr><th id="156">156</th><td>  <em>const</em> <em>char</em>* <dfn class="decl" id="(anonymous)::raw_const" title='(anonymous union)::raw_const' data-ref="(anonymous)::raw_const">raw_const</dfn>;</td></tr>
<tr><th id="157">157</th><td>  <a class="typedef" href="../../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a>* <dfn class="decl" id="(anonymous)::uint8" title='(anonymous union)::uint8' data-ref="(anonymous)::uint8">uint8</dfn>;</td></tr>
<tr><th id="158">158</th><td>} <dfn class="typedef" id="TfLitePtrUnion" title='TfLitePtrUnion' data-type='union TfLitePtrUnion' data-ref="TfLitePtrUnion">TfLitePtrUnion</dfn>;</td></tr>
<tr><th id="159">159</th><td></td></tr>
<tr><th id="160">160</th><td><i>// Memory allocation strategies. kTfLiteMmapRo is for read-only memory-mapped</i></td></tr>
<tr><th id="161">161</th><td><i>// data (or data externally allocated). kTfLiteArenaRw is arena allocated</i></td></tr>
<tr><th id="162">162</th><td><i>// data. kTfLiteDynamic is for tensors that are allocated during evaluation.</i></td></tr>
<tr><th id="163">163</th><td><b>typedef</b> <b>enum</b> {</td></tr>
<tr><th id="164">164</th><td>  <dfn class="enum" id="kTfLiteMemNone" title='kTfLiteMemNone' data-ref="kTfLiteMemNone">kTfLiteMemNone</dfn> = <var>0</var>,</td></tr>
<tr><th id="165">165</th><td>  <dfn class="enum" id="kTfLiteMmapRo" title='kTfLiteMmapRo' data-ref="kTfLiteMmapRo">kTfLiteMmapRo</dfn>,</td></tr>
<tr><th id="166">166</th><td>  <dfn class="enum" id="kTfLiteArenaRw" title='kTfLiteArenaRw' data-ref="kTfLiteArenaRw">kTfLiteArenaRw</dfn>,</td></tr>
<tr><th id="167">167</th><td>  <dfn class="enum" id="kTfLiteArenaRwPersistent" title='kTfLiteArenaRwPersistent' data-ref="kTfLiteArenaRwPersistent">kTfLiteArenaRwPersistent</dfn>,</td></tr>
<tr><th id="168">168</th><td>  <dfn class="enum" id="kTfLiteDynamic" title='kTfLiteDynamic' data-ref="kTfLiteDynamic">kTfLiteDynamic</dfn>,</td></tr>
<tr><th id="169">169</th><td>} <dfn class="typedef" id="TfLiteAllocationType" title='TfLiteAllocationType' data-type='enum TfLiteAllocationType' data-ref="TfLiteAllocationType">TfLiteAllocationType</dfn>;</td></tr>
<tr><th id="170">170</th><td></td></tr>
<tr><th id="171">171</th><td><i>// The delegates should use zero or positive integers to represent handles.</i></td></tr>
<tr><th id="172">172</th><td><i>// -1 is reserved from unallocated status.</i></td></tr>
<tr><th id="173">173</th><td><b>typedef</b> <em>int</em> <dfn class="typedef" id="TfLiteBufferHandle" title='TfLiteBufferHandle' data-type='int' data-ref="TfLiteBufferHandle">TfLiteBufferHandle</dfn>;</td></tr>
<tr><th id="174">174</th><td><em>const</em> <a class="typedef" href="#TfLiteBufferHandle" title='TfLiteBufferHandle' data-type='int' data-ref="TfLiteBufferHandle">TfLiteBufferHandle</a> <dfn class="decl def" id="kTfLiteNullBufferHandle" title='kTfLiteNullBufferHandle' data-ref="kTfLiteNullBufferHandle">kTfLiteNullBufferHandle</dfn> = -<var>1</var>;</td></tr>
<tr><th id="175">175</th><td></td></tr>
<tr><th id="176">176</th><td><i>// An tensor in the interpreter system which is a wrapper around a buffer of</i></td></tr>
<tr><th id="177">177</th><td><i>// data including a dimensionality (or NULL if not currently defined).</i></td></tr>
<tr><th id="178">178</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="179">179</th><td>  <i>// The data type specification for data stored in `data`. This affects</i></td></tr>
<tr><th id="180">180</th><td><i>  // what member of `data` union should be used.</i></td></tr>
<tr><th id="181">181</th><td>  <a class="typedef" href="#TfLiteType" title='TfLiteType' data-type='enum TfLiteType' data-ref="TfLiteType">TfLiteType</a> <dfn class="decl" id="(anonymous)::type" title='(anonymous struct)::type' data-ref="(anonymous)::type">type</dfn>;</td></tr>
<tr><th id="182">182</th><td>  <i>// A union of data pointers. The appropriate type should be used for a typed</i></td></tr>
<tr><th id="183">183</th><td><i>  // tensor based on `type`.</i></td></tr>
<tr><th id="184">184</th><td>  <a class="typedef" href="#TfLitePtrUnion" title='TfLitePtrUnion' data-type='union TfLitePtrUnion' data-ref="TfLitePtrUnion">TfLitePtrUnion</a> <dfn class="decl" id="(anonymous)::data" title='(anonymous struct)::data' data-ref="(anonymous)::data">data</dfn>;</td></tr>
<tr><th id="185">185</th><td>  <i>// A pointer to a structure representing the dimensionality interpretation</i></td></tr>
<tr><th id="186">186</th><td><i>  // that the buffer should have. NOTE: the product of elements of `dims`</i></td></tr>
<tr><th id="187">187</th><td><i>  // and the element datatype size should be equal to `bytes` below.</i></td></tr>
<tr><th id="188">188</th><td>  <a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="decl" id="(anonymous)::dims" title='(anonymous struct)::dims' data-ref="(anonymous)::dims">dims</dfn>;</td></tr>
<tr><th id="189">189</th><td>  <i>// Quantization information.</i></td></tr>
<tr><th id="190">190</th><td>  <a class="typedef" href="#TfLiteQuantizationParams" title='TfLiteQuantizationParams' data-type='struct TfLiteQuantizationParams' data-ref="TfLiteQuantizationParams">TfLiteQuantizationParams</a> <dfn class="decl" id="(anonymous)::params" title='(anonymous struct)::params' data-ref="(anonymous)::params">params</dfn>;</td></tr>
<tr><th id="191">191</th><td>  <i>// How memory is mapped</i></td></tr>
<tr><th id="192">192</th><td><i>  //  kTfLiteMmapRo: Memory mapped read only.</i></td></tr>
<tr><th id="193">193</th><td><i>  //  i.e. weights</i></td></tr>
<tr><th id="194">194</th><td><i>  //  kTfLiteArenaRw: Arena allocated read write memory</i></td></tr>
<tr><th id="195">195</th><td><i>  //  (i.e. temporaries, outputs).</i></td></tr>
<tr><th id="196">196</th><td>  <a class="typedef" href="#TfLiteAllocationType" title='TfLiteAllocationType' data-type='enum TfLiteAllocationType' data-ref="TfLiteAllocationType">TfLiteAllocationType</a> <dfn class="decl" id="(anonymous)::allocation_type" title='(anonymous struct)::allocation_type' data-ref="(anonymous)::allocation_type">allocation_type</dfn>;</td></tr>
<tr><th id="197">197</th><td>  <i>// The number of bytes required to store the data of this Tensor. I.e.</i></td></tr>
<tr><th id="198">198</th><td><i>  // (bytes of each element) * dims[0] * ... * dims[n-1].  For example, if</i></td></tr>
<tr><th id="199">199</th><td><i>  // type is kTfLiteFloat32 and dims = {3, 2} then</i></td></tr>
<tr><th id="200">200</th><td><i>  // bytes = sizeof(float) * 3 * 2 = 4 * 3 * 2 = 24.</i></td></tr>
<tr><th id="201">201</th><td>  <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="decl" id="(anonymous)::bytes" title='(anonymous struct)::bytes' data-ref="(anonymous)::bytes">bytes</dfn>;</td></tr>
<tr><th id="202">202</th><td></td></tr>
<tr><th id="203">203</th><td>  <i>// An opaque pointer to a tflite::MMapAllocation</i></td></tr>
<tr><th id="204">204</th><td>  <em>const</em> <em>void</em>* <dfn class="decl" id="(anonymous)::allocation" title='(anonymous struct)::allocation' data-ref="(anonymous)::allocation">allocation</dfn>;</td></tr>
<tr><th id="205">205</th><td></td></tr>
<tr><th id="206">206</th><td>  <i>// Null-terminated name of this tensor.</i></td></tr>
<tr><th id="207">207</th><td>  <em>const</em> <em>char</em>* <dfn class="decl" id="(anonymous)::name" title='(anonymous struct)::name' data-ref="(anonymous)::name">name</dfn>;</td></tr>
<tr><th id="208">208</th><td></td></tr>
<tr><th id="209">209</th><td>  <i>// The delegate which knows how to handle `buffer_handle`.</i></td></tr>
<tr><th id="210">210</th><td><i>  // WARNING: This is an experimental interface that is subject to change.</i></td></tr>
<tr><th id="211">211</th><td>  <a class="typedef" href="#TfLiteDelegate" title='TfLiteDelegate' data-type='struct _TfLiteDelegate' data-ref="TfLiteDelegate">TfLiteDelegate</a>* <dfn class="decl" id="(anonymous)::delegate" title='(anonymous struct)::delegate' data-ref="(anonymous)::delegate">delegate</dfn>;</td></tr>
<tr><th id="212">212</th><td></td></tr>
<tr><th id="213">213</th><td>  <i>// An integer buffer handle that can be handled by `delegate`.</i></td></tr>
<tr><th id="214">214</th><td><i>  // The value is valid only when delegate is not null.</i></td></tr>
<tr><th id="215">215</th><td><i>  // WARNING: This is an experimental interface that is subject to change.</i></td></tr>
<tr><th id="216">216</th><td>  <a class="typedef" href="#TfLiteBufferHandle" title='TfLiteBufferHandle' data-type='int' data-ref="TfLiteBufferHandle">TfLiteBufferHandle</a> <dfn class="decl" id="(anonymous)::buffer_handle" title='(anonymous struct)::buffer_handle' data-ref="(anonymous)::buffer_handle">buffer_handle</dfn>;</td></tr>
<tr><th id="217">217</th><td></td></tr>
<tr><th id="218">218</th><td>  <i>// If the delegate uses its own buffer (e.g. GPU memory), the delegate is</i></td></tr>
<tr><th id="219">219</th><td><i>  // responsible to set data_is_stale to true.</i></td></tr>
<tr><th id="220">220</th><td><i>  // `delegate-&gt;CopyFromBufferHandle` can be called to copy the data from</i></td></tr>
<tr><th id="221">221</th><td><i>  // delegate buffer.</i></td></tr>
<tr><th id="222">222</th><td><i>  // WARNING: This is an // experimental interface that is subject to change.</i></td></tr>
<tr><th id="223">223</th><td>  <em>bool</em> <dfn class="decl" id="(anonymous)::data_is_stale" title='(anonymous struct)::data_is_stale' data-ref="(anonymous)::data_is_stale">data_is_stale</dfn>;</td></tr>
<tr><th id="224">224</th><td>} <dfn class="typedef" id="TfLiteTensor" title='TfLiteTensor' data-type='struct TfLiteTensor' data-ref="TfLiteTensor">TfLiteTensor</dfn>;</td></tr>
<tr><th id="225">225</th><td></td></tr>
<tr><th id="226">226</th><td><i>// Free data memory of tensor `t`;</i></td></tr>
<tr><th id="227">227</th><td><em>void</em> <dfn class="decl" id="TfLiteTensorDataFree" title='TfLiteTensorDataFree' data-ref="TfLiteTensorDataFree">TfLiteTensorDataFree</dfn>(<a class="typedef" href="#TfLiteTensor" title='TfLiteTensor' data-type='struct TfLiteTensor' data-ref="TfLiteTensor">TfLiteTensor</a>* <dfn class="local col4 decl" id="54t" title='t' data-type='TfLiteTensor *' data-ref="54t">t</dfn>);</td></tr>
<tr><th id="228">228</th><td></td></tr>
<tr><th id="229">229</th><td><i>// Free memory of tensor `t`;</i></td></tr>
<tr><th id="230">230</th><td><em>void</em> <dfn class="decl" id="TfLiteTensorFree" title='TfLiteTensorFree' data-ref="TfLiteTensorFree">TfLiteTensorFree</dfn>(<a class="typedef" href="#TfLiteTensor" title='TfLiteTensor' data-type='struct TfLiteTensor' data-ref="TfLiteTensor">TfLiteTensor</a>* <dfn class="local col5 decl" id="55t" title='t' data-type='TfLiteTensor *' data-ref="55t">t</dfn>);</td></tr>
<tr><th id="231">231</th><td></td></tr>
<tr><th id="232">232</th><td><i>// Set all of a tensor's fields (and free any previously allocated data).</i></td></tr>
<tr><th id="233">233</th><td><em>void</em> <dfn class="decl" id="TfLiteTensorReset" title='TfLiteTensorReset' data-ref="TfLiteTensorReset">TfLiteTensorReset</dfn>(<a class="typedef" href="#TfLiteType" title='TfLiteType' data-type='enum TfLiteType' data-ref="TfLiteType">TfLiteType</a> <dfn class="local col6 decl" id="56type" title='type' data-type='TfLiteType' data-ref="56type">type</dfn>, <em>const</em> <em>char</em>* <dfn class="local col7 decl" id="57name" title='name' data-type='const char *' data-ref="57name">name</dfn>, <a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="local col8 decl" id="58dims" title='dims' data-type='TfLiteIntArray *' data-ref="58dims">dims</dfn>,</td></tr>
<tr><th id="234">234</th><td>                       <a class="typedef" href="#TfLiteQuantizationParams" title='TfLiteQuantizationParams' data-type='struct TfLiteQuantizationParams' data-ref="TfLiteQuantizationParams">TfLiteQuantizationParams</a> <dfn class="local col9 decl" id="59quantization" title='quantization' data-type='TfLiteQuantizationParams' data-ref="59quantization">quantization</dfn>, <em>char</em>* <dfn class="local col0 decl" id="60buffer" title='buffer' data-type='char *' data-ref="60buffer">buffer</dfn>,</td></tr>
<tr><th id="235">235</th><td>                       <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col1 decl" id="61size" title='size' data-type='size_t' data-ref="61size">size</dfn>, <a class="typedef" href="#TfLiteAllocationType" title='TfLiteAllocationType' data-type='enum TfLiteAllocationType' data-ref="TfLiteAllocationType">TfLiteAllocationType</a> <dfn class="local col2 decl" id="62allocation_type" title='allocation_type' data-type='TfLiteAllocationType' data-ref="62allocation_type">allocation_type</dfn>,</td></tr>
<tr><th id="236">236</th><td>                       <em>const</em> <em>void</em>* <dfn class="local col3 decl" id="63allocation" title='allocation' data-type='const void *' data-ref="63allocation">allocation</dfn>, <a class="typedef" href="#TfLiteTensor" title='TfLiteTensor' data-type='struct TfLiteTensor' data-ref="TfLiteTensor">TfLiteTensor</a>* <dfn class="local col4 decl" id="64tensor" title='tensor' data-type='TfLiteTensor *' data-ref="64tensor">tensor</dfn>);</td></tr>
<tr><th id="237">237</th><td></td></tr>
<tr><th id="238">238</th><td><i>// Resize the allocated data of a (dynamic) tensor.</i></td></tr>
<tr><th id="239">239</th><td><em>void</em> <dfn class="decl" id="TfLiteTensorRealloc" title='TfLiteTensorRealloc' data-ref="TfLiteTensorRealloc">TfLiteTensorRealloc</dfn>(<span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col5 decl" id="65num_bytes" title='num_bytes' data-type='size_t' data-ref="65num_bytes">num_bytes</dfn>, <a class="typedef" href="#TfLiteTensor" title='TfLiteTensor' data-type='struct TfLiteTensor' data-ref="TfLiteTensor">TfLiteTensor</a>* <dfn class="local col6 decl" id="66tensor" title='tensor' data-type='TfLiteTensor *' data-ref="66tensor">tensor</dfn>);</td></tr>
<tr><th id="240">240</th><td></td></tr>
<tr><th id="241">241</th><td><i>// A structure representing an instance of a node.</i></td></tr>
<tr><th id="242">242</th><td><i>// This structure only exhibits the inputs, outputs and user defined data, not</i></td></tr>
<tr><th id="243">243</th><td><i>// other features like the type.</i></td></tr>
<tr><th id="244">244</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="245">245</th><td>  <i>// Inputs to this node expressed as indices into the simulator's tensors.</i></td></tr>
<tr><th id="246">246</th><td>  <a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="decl" id="(anonymous)::inputs" title='(anonymous struct)::inputs' data-ref="(anonymous)::inputs">inputs</dfn>;</td></tr>
<tr><th id="247">247</th><td></td></tr>
<tr><th id="248">248</th><td>  <i>// Outputs to this node expressed as indices into the simulator's tensors.</i></td></tr>
<tr><th id="249">249</th><td>  <a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="decl" id="(anonymous)::outputs" title='(anonymous struct)::outputs' data-ref="(anonymous)::outputs">outputs</dfn>;</td></tr>
<tr><th id="250">250</th><td></td></tr>
<tr><th id="251">251</th><td>  <i>// Temporary tensors uses during the computations. This usually contains no</i></td></tr>
<tr><th id="252">252</th><td><i>  // tensors, but ops are allowed to change that if they need scratch space of</i></td></tr>
<tr><th id="253">253</th><td><i>  // any sort.</i></td></tr>
<tr><th id="254">254</th><td>  <a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="decl" id="(anonymous)::temporaries" title='(anonymous struct)::temporaries' data-ref="(anonymous)::temporaries">temporaries</dfn>;</td></tr>
<tr><th id="255">255</th><td></td></tr>
<tr><th id="256">256</th><td>  <i>// Opaque data provided by the node implementer through `Registration.init`.</i></td></tr>
<tr><th id="257">257</th><td>  <em>void</em>* <dfn class="decl" id="(anonymous)::user_data" title='(anonymous struct)::user_data' data-ref="(anonymous)::user_data">user_data</dfn>;</td></tr>
<tr><th id="258">258</th><td></td></tr>
<tr><th id="259">259</th><td>  <i>// Opaque data provided to the node if the node is a builtin. This is usually</i></td></tr>
<tr><th id="260">260</th><td><i>  // a structure defined in builtin_op_data.h</i></td></tr>
<tr><th id="261">261</th><td>  <em>void</em>* <dfn class="decl" id="(anonymous)::builtin_data" title='(anonymous struct)::builtin_data' data-ref="(anonymous)::builtin_data">builtin_data</dfn>;</td></tr>
<tr><th id="262">262</th><td></td></tr>
<tr><th id="263">263</th><td>  <i>// Custom initial data. This is the opaque data provided in the flatbuffer.</i></td></tr>
<tr><th id="264">264</th><td><i>  // WARNING: This is an experimental interface that is subject to change.</i></td></tr>
<tr><th id="265">265</th><td>  <em>const</em> <em>void</em>* <dfn class="decl" id="(anonymous)::custom_initial_data" title='(anonymous struct)::custom_initial_data' data-ref="(anonymous)::custom_initial_data">custom_initial_data</dfn>;</td></tr>
<tr><th id="266">266</th><td>  <em>int</em> <dfn class="decl" id="(anonymous)::custom_initial_data_size" title='(anonymous struct)::custom_initial_data_size' data-ref="(anonymous)::custom_initial_data_size">custom_initial_data_size</dfn>;</td></tr>
<tr><th id="267">267</th><td></td></tr>
<tr><th id="268">268</th><td>  <i>// The pointer to the delegate. This is non-null only when the node is</i></td></tr>
<tr><th id="269">269</th><td><i>  // created by calling `interpreter.ModifyGraphWithDelegate`.</i></td></tr>
<tr><th id="270">270</th><td><i>  // WARNING: This is an experimental interface that is subject to change.</i></td></tr>
<tr><th id="271">271</th><td>  <a class="typedef" href="#TfLiteDelegate" title='TfLiteDelegate' data-type='struct _TfLiteDelegate' data-ref="TfLiteDelegate">TfLiteDelegate</a>* <dfn class="decl" id="(anonymous)::delegate" title='(anonymous struct)::delegate' data-ref="(anonymous)::delegate">delegate</dfn>;</td></tr>
<tr><th id="272">272</th><td>} <dfn class="typedef" id="TfLiteNode" title='TfLiteNode' data-type='struct TfLiteNode' data-ref="TfLiteNode">TfLiteNode</dfn>;</td></tr>
<tr><th id="273">273</th><td></td></tr>
<tr><th id="274">274</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="TfLiteContext" title='TfLiteContext' data-ref="TfLiteContext"><a class="type" href="#TfLiteContext" title='TfLiteContext' data-ref="TfLiteContext">TfLiteContext</a></dfn> {</td></tr>
<tr><th id="275">275</th><td>  <i>// Number of tensors in the context.</i></td></tr>
<tr><th id="276">276</th><td>  <em>int</em> <dfn class="decl" id="TfLiteContext::tensors_size" title='TfLiteContext::tensors_size' data-ref="TfLiteContext::tensors_size">tensors_size</dfn>;</td></tr>
<tr><th id="277">277</th><td></td></tr>
<tr><th id="278">278</th><td>  <i>// The execution plan contains a list of the node indices in execution</i></td></tr>
<tr><th id="279">279</th><td><i>  // order. execution_plan-&gt;size is the current number of nodes. And,</i></td></tr>
<tr><th id="280">280</th><td><i>  // execution_plan-&gt;data[0] is the first node that needs to be run.</i></td></tr>
<tr><th id="281">281</th><td><i>  // TfLiteDelegates can traverse the current execution plan by iterating</i></td></tr>
<tr><th id="282">282</th><td><i>  // through each member of this array and using GetNodeAndRegistration() to</i></td></tr>
<tr><th id="283">283</th><td><i>  // access details about a node. i.e.</i></td></tr>
<tr><th id="284">284</th><td><i>  // TfLiteIntArray* execution_plan;</i></td></tr>
<tr><th id="285">285</th><td><i>  // TF_LITE_ENSURE_STATUS(context-&gt;GetExecutionPlan(context, &amp;execution_plan));</i></td></tr>
<tr><th id="286">286</th><td><i>  // for (int exec_index = 0; exec_index &lt; execution_plan-&gt;size; exec_index++) {</i></td></tr>
<tr><th id="287">287</th><td><i>  //    int node_index = execution_plan-&gt;data[exec_index];</i></td></tr>
<tr><th id="288">288</th><td><i>  //    TfLiteNode* node;</i></td></tr>
<tr><th id="289">289</th><td><i>  //    TfLiteRegistration* reg;</i></td></tr>
<tr><th id="290">290</th><td><i>  //    context-&gt;GetNodeAndRegistration(context, node_index, &amp;node, &amp;reg);</i></td></tr>
<tr><th id="291">291</th><td><i>  // }</i></td></tr>
<tr><th id="292">292</th><td><i>  // WARNING: This is an experimental interface that is subject to change.</i></td></tr>
<tr><th id="293">293</th><td>  <a class="typedef" href="#TfLiteStatus" title='TfLiteStatus' data-type='enum TfLiteStatus' data-ref="TfLiteStatus">TfLiteStatus</a> (*<dfn class="decl" id="TfLiteContext::GetExecutionPlan" title='TfLiteContext::GetExecutionPlan' data-ref="TfLiteContext::GetExecutionPlan">GetExecutionPlan</dfn>)(<b>struct</b> <a class="type" href="#TfLiteContext" title='TfLiteContext' data-ref="TfLiteContext">TfLiteContext</a>* <dfn class="local col7 decl" id="67context" title='context' data-type='struct TfLiteContext *' data-ref="67context">context</dfn>,</td></tr>
<tr><th id="294">294</th><td>                                   <a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>** <dfn class="local col8 decl" id="68execution_plan" title='execution_plan' data-type='TfLiteIntArray **' data-ref="68execution_plan">execution_plan</dfn>);</td></tr>
<tr><th id="295">295</th><td></td></tr>
<tr><th id="296">296</th><td>  <i>// An array of tensors in the interpreter context (of length `tensors_size`)</i></td></tr>
<tr><th id="297">297</th><td>  <a class="typedef" href="#TfLiteTensor" title='TfLiteTensor' data-type='struct TfLiteTensor' data-ref="TfLiteTensor">TfLiteTensor</a>* <dfn class="decl" id="TfLiteContext::tensors" title='TfLiteContext::tensors' data-ref="TfLiteContext::tensors">tensors</dfn>;</td></tr>
<tr><th id="298">298</th><td></td></tr>
<tr><th id="299">299</th><td>  <i>// opaque full context ptr (an opaque c++ data structure)</i></td></tr>
<tr><th id="300">300</th><td>  <em>void</em>* <dfn class="decl" id="TfLiteContext::impl_" title='TfLiteContext::impl_' data-ref="TfLiteContext::impl_">impl_</dfn>;</td></tr>
<tr><th id="301">301</th><td></td></tr>
<tr><th id="302">302</th><td>  <i>// Request memory pointer be resized. Updates dimensions on the tensor.</i></td></tr>
<tr><th id="303">303</th><td><i>  // NOTE: ResizeTensor takes ownership of newSize.</i></td></tr>
<tr><th id="304">304</th><td>  <a class="typedef" href="#TfLiteStatus" title='TfLiteStatus' data-type='enum TfLiteStatus' data-ref="TfLiteStatus">TfLiteStatus</a> (*<dfn class="decl" id="TfLiteContext::ResizeTensor" title='TfLiteContext::ResizeTensor' data-ref="TfLiteContext::ResizeTensor">ResizeTensor</dfn>)(<b>struct</b> <a class="type" href="#TfLiteContext" title='TfLiteContext' data-ref="TfLiteContext">TfLiteContext</a>*, <a class="typedef" href="#TfLiteTensor" title='TfLiteTensor' data-type='struct TfLiteTensor' data-ref="TfLiteTensor">TfLiteTensor</a>* <dfn class="local col9 decl" id="69tensor" title='tensor' data-type='TfLiteTensor *' data-ref="69tensor">tensor</dfn>,</td></tr>
<tr><th id="305">305</th><td>                               <a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="local col0 decl" id="70new_size" title='new_size' data-type='TfLiteIntArray *' data-ref="70new_size">new_size</dfn>);</td></tr>
<tr><th id="306">306</th><td>  <i>// Request that a error be reported with format string msg.</i></td></tr>
<tr><th id="307">307</th><td>  <em>void</em> (*<dfn class="decl" id="TfLiteContext::ReportError" title='TfLiteContext::ReportError' data-ref="TfLiteContext::ReportError">ReportError</dfn>)(<b>struct</b> <a class="type" href="#TfLiteContext" title='TfLiteContext' data-ref="TfLiteContext">TfLiteContext</a>*, <em>const</em> <em>char</em>* <dfn class="local col1 decl" id="71msg" title='msg' data-type='const char *' data-ref="71msg">msg</dfn>, ...);</td></tr>
<tr><th id="308">308</th><td></td></tr>
<tr><th id="309">309</th><td>  <i>// Add `tensors_to_add` tensors, preserving pre-existing Tensor entries.  If</i></td></tr>
<tr><th id="310">310</th><td><i>  // non-null, the value pointed to by `first_new_tensor_index` will be set to</i></td></tr>
<tr><th id="311">311</th><td><i>  // the index of the first new tensor.</i></td></tr>
<tr><th id="312">312</th><td>  <a class="typedef" href="#TfLiteStatus" title='TfLiteStatus' data-type='enum TfLiteStatus' data-ref="TfLiteStatus">TfLiteStatus</a> (*<dfn class="decl" id="TfLiteContext::AddTensors" title='TfLiteContext::AddTensors' data-ref="TfLiteContext::AddTensors">AddTensors</dfn>)(<b>struct</b> <a class="type" href="#TfLiteContext" title='TfLiteContext' data-ref="TfLiteContext">TfLiteContext</a>*, <em>int</em> <dfn class="local col2 decl" id="72tensors_to_add" title='tensors_to_add' data-type='int' data-ref="72tensors_to_add">tensors_to_add</dfn>,</td></tr>
<tr><th id="313">313</th><td>                             <em>int</em>* <dfn class="local col3 decl" id="73first_new_tensor_index" title='first_new_tensor_index' data-type='int *' data-ref="73first_new_tensor_index">first_new_tensor_index</dfn>);</td></tr>
<tr><th id="314">314</th><td></td></tr>
<tr><th id="315">315</th><td>  <i>// Get a Tensor node by node_index.</i></td></tr>
<tr><th id="316">316</th><td><i>  // WARNING: This is an experimental interface that is subject to change.</i></td></tr>
<tr><th id="317">317</th><td>  <a class="typedef" href="#TfLiteStatus" title='TfLiteStatus' data-type='enum TfLiteStatus' data-ref="TfLiteStatus">TfLiteStatus</a> (*<dfn class="decl" id="TfLiteContext::GetNodeAndRegistration" title='TfLiteContext::GetNodeAndRegistration' data-ref="TfLiteContext::GetNodeAndRegistration">GetNodeAndRegistration</dfn>)(<b>struct</b> <a class="type" href="#TfLiteContext" title='TfLiteContext' data-ref="TfLiteContext">TfLiteContext</a>*, <em>int</em> <dfn class="local col4 decl" id="74node_index" title='node_index' data-type='int' data-ref="74node_index">node_index</dfn>,</td></tr>
<tr><th id="318">318</th><td>                                         <a class="typedef" href="#TfLiteNode" title='TfLiteNode' data-type='struct TfLiteNode' data-ref="TfLiteNode">TfLiteNode</a>** <dfn class="local col5 decl" id="75node" title='node' data-type='TfLiteNode **' data-ref="75node">node</dfn>,</td></tr>
<tr><th id="319">319</th><td>                                         <a class="typedef" href="#TfLiteRegistration" title='TfLiteRegistration' data-type='struct _TfLiteRegistration' data-ref="TfLiteRegistration">TfLiteRegistration</a>** <dfn class="local col6 decl" id="76registration" title='registration' data-type='TfLiteRegistration **' data-ref="76registration">registration</dfn>);</td></tr>
<tr><th id="320">320</th><td></td></tr>
<tr><th id="321">321</th><td>  <i>// Replace ops with one or more stub delegate operations. This function</i></td></tr>
<tr><th id="322">322</th><td><i>  // does not take ownership of `nodes_to_replace`.</i></td></tr>
<tr><th id="323">323</th><td>  <a class="typedef" href="#TfLiteStatus" title='TfLiteStatus' data-type='enum TfLiteStatus' data-ref="TfLiteStatus">TfLiteStatus</a> (*<dfn class="decl" id="TfLiteContext::ReplaceSubgraphsWithDelegateKernels" title='TfLiteContext::ReplaceSubgraphsWithDelegateKernels' data-ref="TfLiteContext::ReplaceSubgraphsWithDelegateKernels">ReplaceSubgraphsWithDelegateKernels</dfn>)(</td></tr>
<tr><th id="324">324</th><td>      <b>struct</b> <a class="type" href="#TfLiteContext" title='TfLiteContext' data-ref="TfLiteContext">TfLiteContext</a>*, <a class="typedef" href="#TfLiteRegistration" title='TfLiteRegistration' data-type='struct _TfLiteRegistration' data-ref="TfLiteRegistration">TfLiteRegistration</a> <dfn class="local col7 decl" id="77registration" title='registration' data-type='TfLiteRegistration' data-ref="77registration">registration</dfn>,</td></tr>
<tr><th id="325">325</th><td>      <em>const</em> <a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="local col8 decl" id="78nodes_to_replace" title='nodes_to_replace' data-type='const TfLiteIntArray *' data-ref="78nodes_to_replace">nodes_to_replace</dfn>, <a class="typedef" href="#TfLiteDelegate" title='TfLiteDelegate' data-type='struct _TfLiteDelegate' data-ref="TfLiteDelegate">TfLiteDelegate</a>* <dfn class="local col9 decl" id="79delegate" title='delegate' data-type='TfLiteDelegate *' data-ref="79delegate">delegate</dfn>);</td></tr>
<tr><th id="326">326</th><td></td></tr>
<tr><th id="327">327</th><td>  <i>// Number of threads that are recommended to subsystems like gemmlowp and</i></td></tr>
<tr><th id="328">328</th><td><i>  // eigen.</i></td></tr>
<tr><th id="329">329</th><td>  <em>int</em> <dfn class="decl" id="TfLiteContext::recommended_num_threads" title='TfLiteContext::recommended_num_threads' data-ref="TfLiteContext::recommended_num_threads">recommended_num_threads</dfn>;</td></tr>
<tr><th id="330">330</th><td></td></tr>
<tr><th id="331">331</th><td>  <i>// TODO(ahentz): we should create a more general mechanism for this sort of</i></td></tr>
<tr><th id="332">332</th><td><i>  // library-global objects.</i></td></tr>
<tr><th id="333">333</th><td>  <em>void</em>* <dfn class="decl" id="TfLiteContext::gemm_context" title='TfLiteContext::gemm_context' data-ref="TfLiteContext::gemm_context">gemm_context</dfn>;</td></tr>
<tr><th id="334">334</th><td>  <em>void</em>* <dfn class="decl" id="TfLiteContext::eigen_context" title='TfLiteContext::eigen_context' data-ref="TfLiteContext::eigen_context">eigen_context</dfn>;</td></tr>
<tr><th id="335">335</th><td>} <dfn class="typedef" id="TfLiteContext" title='TfLiteContext' data-type='struct TfLiteContext' data-ref="TfLiteContext">TfLiteContext</dfn>;</td></tr>
<tr><th id="336">336</th><td></td></tr>
<tr><th id="337">337</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_TfLiteRegistration" title='_TfLiteRegistration' data-ref="_TfLiteRegistration"><a class="type" href="#_TfLiteRegistration" title='_TfLiteRegistration' data-ref="_TfLiteRegistration">_TfLiteRegistration</a></dfn> {</td></tr>
<tr><th id="338">338</th><td>  <i>// Initializes the op from serialized data.</i></td></tr>
<tr><th id="339">339</th><td><i>  // If a built-in op:</i></td></tr>
<tr><th id="340">340</th><td><i>  //   `buffer` is the op's params data (TfLiteLSTMParams*).</i></td></tr>
<tr><th id="341">341</th><td><i>  //   `length` is zero.</i></td></tr>
<tr><th id="342">342</th><td><i>  // If custom op:</i></td></tr>
<tr><th id="343">343</th><td><i>  //   `buffer` is the op's `custom_options`.</i></td></tr>
<tr><th id="344">344</th><td><i>  //   `length` is the size of the buffer.</i></td></tr>
<tr><th id="345">345</th><td><i>  //</i></td></tr>
<tr><th id="346">346</th><td><i>  // Returns a type-punned (i.e. void*) opaque data (e.g. a primitive pointer</i></td></tr>
<tr><th id="347">347</th><td><i>  // or an instance of a struct).</i></td></tr>
<tr><th id="348">348</th><td><i>  //</i></td></tr>
<tr><th id="349">349</th><td><i>  // The returned pointer will be stored with the node in the `user_data` field,</i></td></tr>
<tr><th id="350">350</th><td><i>  // accessible within prepare and invoke functions below.</i></td></tr>
<tr><th id="351">351</th><td><i>  // NOTE: if the data is already in the desired format, simply implement this</i></td></tr>
<tr><th id="352">352</th><td><i>  // function to return `nullptr` and implement the free function to be a no-op.</i></td></tr>
<tr><th id="353">353</th><td>  <em>void</em>* (*<dfn class="decl" id="_TfLiteRegistration::init" title='_TfLiteRegistration::init' data-ref="_TfLiteRegistration::init">init</dfn>)(<a class="typedef" href="#TfLiteContext" title='TfLiteContext' data-type='struct TfLiteContext' data-ref="TfLiteContext">TfLiteContext</a>* <dfn class="local col0 decl" id="80context" title='context' data-type='TfLiteContext *' data-ref="80context">context</dfn>, <em>const</em> <em>char</em>* <dfn class="local col1 decl" id="81buffer" title='buffer' data-type='const char *' data-ref="81buffer">buffer</dfn>, <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col2 decl" id="82length" title='length' data-type='size_t' data-ref="82length">length</dfn>);</td></tr>
<tr><th id="354">354</th><td></td></tr>
<tr><th id="355">355</th><td>  <i>// The pointer `buffer` is the data previously returned by an init invocation.</i></td></tr>
<tr><th id="356">356</th><td>  <em>void</em> (*<dfn class="decl" id="_TfLiteRegistration::free" title='_TfLiteRegistration::free' data-ref="_TfLiteRegistration::free">free</dfn>)(<a class="typedef" href="#TfLiteContext" title='TfLiteContext' data-type='struct TfLiteContext' data-ref="TfLiteContext">TfLiteContext</a>* <dfn class="local col3 decl" id="83context" title='context' data-type='TfLiteContext *' data-ref="83context">context</dfn>, <em>void</em>* <dfn class="local col4 decl" id="84buffer" title='buffer' data-type='void *' data-ref="84buffer">buffer</dfn>);</td></tr>
<tr><th id="357">357</th><td></td></tr>
<tr><th id="358">358</th><td>  <i>// prepare is called when the inputs this node depends on have been resized.</i></td></tr>
<tr><th id="359">359</th><td><i>  // context-&gt;ResizeTensor() can be called to request output tensors to be</i></td></tr>
<tr><th id="360">360</th><td><i>  // resized.</i></td></tr>
<tr><th id="361">361</th><td><i>  //</i></td></tr>
<tr><th id="362">362</th><td><i>  // Returns kTfLiteOk on success.</i></td></tr>
<tr><th id="363">363</th><td>  <a class="typedef" href="#TfLiteStatus" title='TfLiteStatus' data-type='enum TfLiteStatus' data-ref="TfLiteStatus">TfLiteStatus</a> (*<dfn class="decl" id="_TfLiteRegistration::prepare" title='_TfLiteRegistration::prepare' data-ref="_TfLiteRegistration::prepare">prepare</dfn>)(<a class="typedef" href="#TfLiteContext" title='TfLiteContext' data-type='struct TfLiteContext' data-ref="TfLiteContext">TfLiteContext</a>* <dfn class="local col5 decl" id="85context" title='context' data-type='TfLiteContext *' data-ref="85context">context</dfn>, <a class="typedef" href="#TfLiteNode" title='TfLiteNode' data-type='struct TfLiteNode' data-ref="TfLiteNode">TfLiteNode</a>* <dfn class="local col6 decl" id="86node" title='node' data-type='TfLiteNode *' data-ref="86node">node</dfn>);</td></tr>
<tr><th id="364">364</th><td></td></tr>
<tr><th id="365">365</th><td>  <i>// Execute the node (should read node-&gt;inputs and output to node-&gt;outputs).</i></td></tr>
<tr><th id="366">366</th><td><i>  // Returns kTfLiteOk on success.</i></td></tr>
<tr><th id="367">367</th><td>  <a class="typedef" href="#TfLiteStatus" title='TfLiteStatus' data-type='enum TfLiteStatus' data-ref="TfLiteStatus">TfLiteStatus</a> (*<dfn class="decl" id="_TfLiteRegistration::invoke" title='_TfLiteRegistration::invoke' data-ref="_TfLiteRegistration::invoke">invoke</dfn>)(<a class="typedef" href="#TfLiteContext" title='TfLiteContext' data-type='struct TfLiteContext' data-ref="TfLiteContext">TfLiteContext</a>* <dfn class="local col7 decl" id="87context" title='context' data-type='TfLiteContext *' data-ref="87context">context</dfn>, <a class="typedef" href="#TfLiteNode" title='TfLiteNode' data-type='struct TfLiteNode' data-ref="TfLiteNode">TfLiteNode</a>* <dfn class="local col8 decl" id="88node" title='node' data-type='TfLiteNode *' data-ref="88node">node</dfn>);</td></tr>
<tr><th id="368">368</th><td></td></tr>
<tr><th id="369">369</th><td>  <i>// Builtin codes. If this kernel refers to a builtin this is the code</i></td></tr>
<tr><th id="370">370</th><td><i>  // of the builtin. This is so we can do marshaling to other frameworks like</i></td></tr>
<tr><th id="371">371</th><td><i>  // NN API. Note, it is the responsibility of the registration binder to</i></td></tr>
<tr><th id="372">372</th><td><i>  // set this properly.</i></td></tr>
<tr><th id="373">373</th><td>  <a class="typedef" href="../../../../include/x86_64-linux-gnu/sys/types.h.html#196" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="decl" id="_TfLiteRegistration::builtin_code" title='_TfLiteRegistration::builtin_code' data-ref="_TfLiteRegistration::builtin_code">builtin_code</dfn>;</td></tr>
<tr><th id="374">374</th><td></td></tr>
<tr><th id="375">375</th><td>  <i>// Custom op name. If the op is a builtin, this will be null.</i></td></tr>
<tr><th id="376">376</th><td><i>  // WARNING: This is an experimental interface that is subject to change.</i></td></tr>
<tr><th id="377">377</th><td>  <em>const</em> <em>char</em>* <dfn class="decl" id="_TfLiteRegistration::custom_name" title='_TfLiteRegistration::custom_name' data-ref="_TfLiteRegistration::custom_name">custom_name</dfn>;</td></tr>
<tr><th id="378">378</th><td>} <a class="typedef" href="#TfLiteRegistration" title='TfLiteRegistration' data-type='struct _TfLiteRegistration' data-ref="TfLiteRegistration">TfLiteRegistration</a>;</td></tr>
<tr><th id="379">379</th><td></td></tr>
<tr><th id="380">380</th><td><i>// WARNING: This is an experimental interface that is subject to change.</i></td></tr>
<tr><th id="381">381</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_TfLiteDelegate" title='_TfLiteDelegate' data-ref="_TfLiteDelegate"><a class="type" href="#_TfLiteDelegate" title='_TfLiteDelegate' data-ref="_TfLiteDelegate">_TfLiteDelegate</a></dfn> {</td></tr>
<tr><th id="382">382</th><td>  <i>// Data that delegate needs to identify itself. This data is owned by the</i></td></tr>
<tr><th id="383">383</th><td><i>  // delegate. The delegate is owned in the user code, so the delegate is</i></td></tr>
<tr><th id="384">384</th><td><i>  // responsible for doing this when it is destroyed.</i></td></tr>
<tr><th id="385">385</th><td>  <em>void</em>* <dfn class="decl" id="_TfLiteDelegate::data_" title='_TfLiteDelegate::data_' data-ref="_TfLiteDelegate::data_">data_</dfn>;</td></tr>
<tr><th id="386">386</th><td></td></tr>
<tr><th id="387">387</th><td>  <i>// Invoked by ModifyGraphWithDelegate. This prepare is called, giving the</i></td></tr>
<tr><th id="388">388</th><td><i>  // delegate a view of the current graph through TfLiteContext*. It typically</i></td></tr>
<tr><th id="389">389</th><td><i>  // will look at the nodes and call ReplaceSubgraphsWithDelegateKernels()</i></td></tr>
<tr><th id="390">390</th><td><i>  // to ask the TensorFlow lite runtime to create macro-nodes to represent</i></td></tr>
<tr><th id="391">391</th><td><i>  // delegated subgraphs of the original graph.</i></td></tr>
<tr><th id="392">392</th><td>  <a class="typedef" href="#TfLiteStatus" title='TfLiteStatus' data-type='enum TfLiteStatus' data-ref="TfLiteStatus">TfLiteStatus</a> (*<dfn class="decl" id="_TfLiteDelegate::Prepare" title='_TfLiteDelegate::Prepare' data-ref="_TfLiteDelegate::Prepare">Prepare</dfn>)(<a class="typedef" href="#TfLiteContext" title='TfLiteContext' data-type='struct TfLiteContext' data-ref="TfLiteContext">TfLiteContext</a>* <dfn class="local col9 decl" id="89context" title='context' data-type='TfLiteContext *' data-ref="89context">context</dfn>, <a class="typedef" href="#TfLiteDelegate" title='TfLiteDelegate' data-type='struct _TfLiteDelegate' data-ref="TfLiteDelegate">TfLiteDelegate</a>* <dfn class="local col0 decl" id="90delegate" title='delegate' data-type='TfLiteDelegate *' data-ref="90delegate">delegate</dfn>);</td></tr>
<tr><th id="393">393</th><td></td></tr>
<tr><th id="394">394</th><td>  <i>// Copy the data from delegate buffer handle to raw memory.</i></td></tr>
<tr><th id="395">395</th><td><i>  // This can be null if the delegate doesn't use its own buffer.</i></td></tr>
<tr><th id="396">396</th><td>  <a class="typedef" href="#TfLiteStatus" title='TfLiteStatus' data-type='enum TfLiteStatus' data-ref="TfLiteStatus">TfLiteStatus</a> (*<dfn class="decl" id="_TfLiteDelegate::CopyFromBufferHandle" title='_TfLiteDelegate::CopyFromBufferHandle' data-ref="_TfLiteDelegate::CopyFromBufferHandle">CopyFromBufferHandle</dfn>)(<a class="typedef" href="#TfLiteDelegate" title='TfLiteDelegate' data-type='struct _TfLiteDelegate' data-ref="TfLiteDelegate">TfLiteDelegate</a>* <dfn class="local col1 decl" id="91delegate" title='delegate' data-type='TfLiteDelegate *' data-ref="91delegate">delegate</dfn>,</td></tr>
<tr><th id="397">397</th><td>                                       <a class="typedef" href="#TfLiteBufferHandle" title='TfLiteBufferHandle' data-type='int' data-ref="TfLiteBufferHandle">TfLiteBufferHandle</a> <dfn class="local col2 decl" id="92buffer_handle" title='buffer_handle' data-type='TfLiteBufferHandle' data-ref="92buffer_handle">buffer_handle</dfn>,</td></tr>
<tr><th id="398">398</th><td>                                       <em>void</em>* <dfn class="local col3 decl" id="93data" title='data' data-type='void *' data-ref="93data">data</dfn>, <em>int</em> <dfn class="local col4 decl" id="94size" title='size' data-type='int' data-ref="94size">size</dfn>);</td></tr>
<tr><th id="399">399</th><td></td></tr>
<tr><th id="400">400</th><td>  <i>// Copy the data from raw memory to delegate buffer handle.</i></td></tr>
<tr><th id="401">401</th><td><i>  // This can be null if the delegate doesn't use its own buffer.</i></td></tr>
<tr><th id="402">402</th><td>  <a class="typedef" href="#TfLiteStatus" title='TfLiteStatus' data-type='enum TfLiteStatus' data-ref="TfLiteStatus">TfLiteStatus</a> (*<dfn class="decl" id="_TfLiteDelegate::CopyToBufferHandle" title='_TfLiteDelegate::CopyToBufferHandle' data-ref="_TfLiteDelegate::CopyToBufferHandle">CopyToBufferHandle</dfn>)(<a class="typedef" href="#TfLiteDelegate" title='TfLiteDelegate' data-type='struct _TfLiteDelegate' data-ref="TfLiteDelegate">TfLiteDelegate</a>* <dfn class="local col5 decl" id="95delegate" title='delegate' data-type='TfLiteDelegate *' data-ref="95delegate">delegate</dfn>,</td></tr>
<tr><th id="403">403</th><td>                                     <a class="typedef" href="#TfLiteBufferHandle" title='TfLiteBufferHandle' data-type='int' data-ref="TfLiteBufferHandle">TfLiteBufferHandle</a> <dfn class="local col6 decl" id="96buffer_handle" title='buffer_handle' data-type='TfLiteBufferHandle' data-ref="96buffer_handle">buffer_handle</dfn>,</td></tr>
<tr><th id="404">404</th><td>                                     <em>void</em>* <dfn class="local col7 decl" id="97data" title='data' data-type='void *' data-ref="97data">data</dfn>, <em>int</em> <dfn class="local col8 decl" id="98size" title='size' data-type='int' data-ref="98size">size</dfn>);</td></tr>
<tr><th id="405">405</th><td></td></tr>
<tr><th id="406">406</th><td>  <i>// Free the Delegate Buffer Handle. Note: This only frees the handle, but</i></td></tr>
<tr><th id="407">407</th><td><i>  // this doesn't release the underlying resource (e.g. textures). The</i></td></tr>
<tr><th id="408">408</th><td><i>  // resources are either owned by application layer or the delegate.</i></td></tr>
<tr><th id="409">409</th><td><i>  // This can be null if the delegate doesn't use its own buffer.</i></td></tr>
<tr><th id="410">410</th><td>  <em>void</em> (*<dfn class="decl" id="_TfLiteDelegate::FreeBufferHandle" title='_TfLiteDelegate::FreeBufferHandle' data-ref="_TfLiteDelegate::FreeBufferHandle">FreeBufferHandle</dfn>)(<a class="typedef" href="#TfLiteDelegate" title='TfLiteDelegate' data-type='struct _TfLiteDelegate' data-ref="TfLiteDelegate">TfLiteDelegate</a>* <dfn class="local col9 decl" id="99delegate" title='delegate' data-type='TfLiteDelegate *' data-ref="99delegate">delegate</dfn>,</td></tr>
<tr><th id="411">411</th><td>                           <a class="typedef" href="#TfLiteBufferHandle" title='TfLiteBufferHandle' data-type='int' data-ref="TfLiteBufferHandle">TfLiteBufferHandle</a>* <dfn class="local col0 decl" id="100handle" title='handle' data-type='TfLiteBufferHandle *' data-ref="100handle">handle</dfn>);</td></tr>
<tr><th id="412">412</th><td>} <a class="typedef" href="#TfLiteDelegate" title='TfLiteDelegate' data-type='struct _TfLiteDelegate' data-ref="TfLiteDelegate">TfLiteDelegate</a>;</td></tr>
<tr><th id="413">413</th><td></td></tr>
<tr><th id="414">414</th><td><i>// WARNING: This is an experimental interface that is subject to change.</i></td></tr>
<tr><th id="415">415</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="416">416</th><td>  <a class="typedef" href="#TfLiteDelegate" title='TfLiteDelegate' data-type='struct _TfLiteDelegate' data-ref="TfLiteDelegate">TfLiteDelegate</a>* <dfn class="decl" id="(anonymous)::delegate" title='(anonymous struct)::delegate' data-ref="(anonymous)::delegate">delegate</dfn>;</td></tr>
<tr><th id="417">417</th><td>  <a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="decl" id="(anonymous)::nodes_to_replace" title='(anonymous struct)::nodes_to_replace' data-ref="(anonymous)::nodes_to_replace">nodes_to_replace</dfn>;</td></tr>
<tr><th id="418">418</th><td>  <a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="decl" id="(anonymous)::input_tensors" title='(anonymous struct)::input_tensors' data-ref="(anonymous)::input_tensors">input_tensors</dfn>;</td></tr>
<tr><th id="419">419</th><td>  <a class="typedef" href="#TfLiteIntArray" title='TfLiteIntArray' data-type='struct TfLiteIntArray' data-ref="TfLiteIntArray">TfLiteIntArray</a>* <dfn class="decl" id="(anonymous)::output_tensors" title='(anonymous struct)::output_tensors' data-ref="(anonymous)::output_tensors">output_tensors</dfn>;</td></tr>
<tr><th id="420">420</th><td>} <dfn class="typedef" id="TfLiteDelegateParams" title='TfLiteDelegateParams' data-type='struct TfLiteDelegateParams' data-ref="TfLiteDelegateParams">TfLiteDelegateParams</dfn>;</td></tr>
<tr><th id="421">421</th><td></td></tr>
<tr><th id="422">422</th><td><u>#<span data-ppcond="422">ifdef</span> <span class="macro" data-ref="_M/__cplusplus">__cplusplus</span></u></td></tr>
<tr><th id="423">423</th><td>}  <i>// extern "C"</i></td></tr>
<tr><th id="424">424</th><td><u>#<span data-ppcond="422">endif</span>  // __cplusplus</u></td></tr>
<tr><th id="425">425</th><td><u>#<span data-ppcond="29">endif</span>  // TENSORFLOW_CONTRIB_LITE_CONTEXT_H_</u></td></tr>
<tr><th id="426">426</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='allocation.cc.html'>tensorflow/tensorflow/contrib/lite/allocation.cc</a><br/>Generated on <em>2018-Aug-20</em> from project tensorflow revision <em>v1.8</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
