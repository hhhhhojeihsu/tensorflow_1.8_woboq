<dec f='tensorflow/tensorflow/core/lib/jpeg/jpeg_mem.h' l='99' type='uint8 * tensorflow::jpeg::Uncompress(const void * srcdata, int datasize, const tensorflow::jpeg::UncompressFlags &amp; flags, int64 * nwarn, std::function&lt;uint8 *(int, int, int)&gt; allocate_output)'/>
<use f='tensorflow/tensorflow/core/kernels/decode_image_op.cc' l='214' u='c' c='_ZN10tensorflow12_GLOBAL__N_113DecodeImageOp10DecodeJpegEPNS_15OpKernelContextENS_11StringPieceE'/>
<doc f='tensorflow/tensorflow/core/lib/jpeg/jpeg_mem.h' l='94'>// Version of Uncompress that allocates memory via a callback.  The callback
// arguments are (width, height, components).  If the size is known ahead of
// time this function can return an existing buffer; passing a callback allows
// the buffer to be shaped based on the JPEG header.  The caller is responsible
// for freeing the memory *even along error paths*.</doc>
<def f='tensorflow/tensorflow/core/lib/jpeg/jpeg_mem.cc' l='488' ll='515' type='uint8 * tensorflow::jpeg::Uncompress(const void * srcdata, int datasize, const tensorflow::jpeg::UncompressFlags &amp; flags, int64 * nwarn, std::function&lt;uint8 *(int, int, int)&gt; allocate_output)'/>
<use f='tensorflow/tensorflow/core/lib/jpeg/jpeg_mem.cc' l='522' u='c' c='_ZN10tensorflow4jpeg10UncompressEPKviRKNS0_15UncompressFlagsEPiS6_S6_Px'/>
<doc f='tensorflow/tensorflow/core/lib/jpeg/jpeg_mem.cc' l='480'>// -----------------------------------------------------------------------------
//  We do the apparently silly thing of packing 5 of the arguments
//  into a structure that is then passed to another routine
//  that does all the work.  The reason is that we want to catch
//  fatal JPEG library errors with setjmp/longjmp, and g++ and
//  associated libraries aren&apos;t good enough to guarantee that 7
//  parameters won&apos;t get clobbered by the longjmp.  So we help
//  it out a little.</doc>
