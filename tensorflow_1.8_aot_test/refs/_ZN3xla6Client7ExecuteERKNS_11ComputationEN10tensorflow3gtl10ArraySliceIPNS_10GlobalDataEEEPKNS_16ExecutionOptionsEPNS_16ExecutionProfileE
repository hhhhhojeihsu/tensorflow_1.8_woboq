<dec f='tensorflow/tensorflow/compiler/xla/client/client.h' l='55' type='StatusOr&lt;std::unique_ptr&lt;GlobalData&gt; &gt; xla::Client::Execute(const xla::Computation &amp; computation, tensorflow::gtl::ArraySlice&lt;GlobalData *&gt; arguments, const xla::ExecutionOptions * execution_options = nullptr, xla::ExecutionProfile * execution_profile = nullptr)'/>
<doc f='tensorflow/tensorflow/compiler/xla/client/client.h' l='44'>// Executes the computation with the given arguments and returns the global
  // data that was produced from the execution.
  // * If execution_options is not nullptr, these options are passed to the
  //   service to affect how it compiles our computation.  (The pointer does not
  //   need to live beyond this call.)
  // * If execution_options.device_handles is not empty, the computation is
  //   executed on the devices associated with the handles by partitioning the
  //   computation based on the attached sharding attributes. Otherwise, a
  //   device is chosen by the service.
  // * If execution_profile is not nullptr then the pointed-to ExecutionProfile
  //   will be filled with profile data from the execution.</doc>
<use f='tensorflow/tensorflow/compiler/xla/client/client.cc' l='171' u='c' c='_ZN3xla6Client18ExecuteAndTransferERKNS_11ComputationEN10tensorflow3gtl10ArraySliceIPNS_10GlobalDataEEEPKNS_16ExecutionOptionsEPNS_16ExecutionProfileE'/>
<def f='tensorflow/tensorflow/compiler/xla/client/client.cc' l='210' ll='248' type='StatusOr&lt;std::unique_ptr&lt;GlobalData&gt; &gt; xla::Client::Execute(const xla::Computation &amp; computation, tensorflow::gtl::ArraySlice&lt;GlobalData *&gt; arguments, const xla::ExecutionOptions * execution_options = nullptr, xla::ExecutionProfile * execution_profile = nullptr)'/>
