<dec f='tensorflow/tensorflow/compiler/aot/embedded_protocol_buffers.h' l='65' type='StatusOr&lt;tensorflow::tfcompile::EmbeddedProtocolBuffer&gt; tensorflow::tfcompile::CreateEmbeddedProtocolBuffer(tensorflow::StringPiece target_triple, tensorflow::StringPiece symbol_prefix, tensorflow::StringPiece qualified_cpp_protobuf_name, const ::tensorflow::protobuf::MessageLite * proto)'/>
<use f='tensorflow/tensorflow/compiler/aot/codegen.cc' l='555' u='c' c='_ZN10tensorflow9tfcompile16GenerateMetadataERKNS0_11CodegenOptsERKNS0_13CompileResultEPNS0_14MetadataResultE'/>
<doc f='tensorflow/tensorflow/compiler/aot/embedded_protocol_buffers.h' l='48'>// Creates an object file that contains `proto`.
//
// `proto` is allowed to be nullptr, in which case the generated C++ shim
// expression is just `nullptr`, and the generated object file does not define
// any symbols.
//
// `target_triple` is the target triple for the target architecture for the
// generated object file.
//
// `symbol_prefix` is prefix that is guaranteed to be unique across the binary
// or DSO the generated object file will be linked into.
//
// `qualified_cpp_protobuf_name` is a qualified (&quot;qualified&quot; as in C++
// namespace qualified) protocol buffer name.  This needs is only used in
// EmbeddedProtocolBuffer::cpp_shim_expression so relatively qualified
// names are fine as long as they&apos;re valid wherever cpp_shim_expression
// is emitted.</doc>
<def f='tensorflow/tensorflow/compiler/aot/embedded_protocol_buffers.cc' l='119' ll='155' type='StatusOr&lt;tensorflow::tfcompile::EmbeddedProtocolBuffer&gt; tensorflow::tfcompile::CreateEmbeddedProtocolBuffer(tensorflow::StringPiece target_triple, tensorflow::StringPiece symbol_prefix, tensorflow::StringPiece qualified_cpp_protobuf_name, const ::tensorflow::protobuf::MessageLite * proto)'/>
