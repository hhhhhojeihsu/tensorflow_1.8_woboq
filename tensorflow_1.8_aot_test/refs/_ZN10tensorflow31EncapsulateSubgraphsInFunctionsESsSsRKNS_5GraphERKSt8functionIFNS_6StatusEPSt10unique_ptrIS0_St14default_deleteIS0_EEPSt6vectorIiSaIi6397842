<dec f='tensorflow/tensorflow/compiler/jit/encapsulate_subgraphs_pass.h' l='76' type='tensorflow::Status tensorflow::EncapsulateSubgraphsInFunctions(string group_attribute, string outside_compilation_attribute, const tensorflow::Graph &amp; graph_in, const RewriteSubgraphFn &amp; rewrite_subgraph_fn, bool parallel_checking, bool reuse_existing_functions, std::unique_ptr&lt;Graph&gt; * graph_out, tensorflow::FunctionLibraryDefinition * library)'/>
<doc f='tensorflow/tensorflow/compiler/jit/encapsulate_subgraphs_pass.h' l='44'>// Transformation that finds subgraphs whose nodes are marked with
// &apos;group_attribute&apos;, splits those subgraphs into functions, and replaces
// the originals with function calls.
//
// &apos;group_attribute&apos; must be a string valued-attribute that names the new
// functions to introduce.
//
// &apos;outside_compilation_attribute&apos; must be a string-valued attribute that is
// used to tag nodes within a subgraph to be part of an &apos;outside_compilation&apos;
// cluster within the subgraph. A cluster is formed from the set of nodes with
// the same value of outside_compilation_subgraph and group_attribute. The nodes
// in an outside_compilation cluster are left in the original graph. Edges
// crossing from the subgraph to an outside_compilation cluster nested in the
// subgraph are lifted into a SendToHost/RecvAtHost pair of nodes, and edges
// crossing from an outside_compilation cluster into its enclosing subgraph are
// lifted into a SendFromHost/RecvFromHost pair of nodes.
//
// If &apos;rewrite_subgraph_fn&apos; is set, it is applied to each subgraph before
// function conversion.
//
// If &apos;parallel_checking&apos; is true, the unencapsulated operators are added to the
// output graph, together with a &quot;ParallelCheck&quot; operator, that verifies that
// the original and encapsulated subgraphs produce similar results.
//
// If &apos;reuse_existing_functions&apos; is set, use an existing function with the
// same name, if any.
//
// TODO(phawkins): currently, some information in control edges
// is not preserved. Suppose you have A and B in the main
// graph, C and D in a subgraph. B and C have control deps from A, D has control
// dep from B. Originally D must run after C, post-transformation this
// dependency is lost.</doc>
<def f='tensorflow/tensorflow/compiler/jit/encapsulate_subgraphs_pass.cc' l='2084' ll='2106' type='tensorflow::Status tensorflow::EncapsulateSubgraphsInFunctions(string group_attribute, string outside_compilation_attribute, const tensorflow::Graph &amp; graph_in, const RewriteSubgraphFn &amp; rewrite_subgraph_fn, bool parallel_checking, bool reuse_existing_functions, std::unique_ptr&lt;Graph&gt; * graph_out, tensorflow::FunctionLibraryDefinition * library)'/>
<use f='tensorflow/tensorflow/compiler/jit/encapsulate_subgraphs_pass.cc' l='2219' u='c' c='_ZN10tensorflow24EncapsulateSubgraphsPass3RunERKNS_28GraphOptimizationPassOptionsE'/>
